<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction to the Dark Arts</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="reverse-engineering/reverse-engineering.html"><strong aria-hidden="true">1.</strong> Reverse engineering</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reverse-engineering/static-reverse-engineering.html"><strong aria-hidden="true">1.1.</strong> Static reverse engineering</a></li><li class="chapter-item expanded "><a href="reverse-engineering/dynamic-reverse-engineering.html"><strong aria-hidden="true">1.2.</strong> Dynamic reverse engineering</a></li><li class="chapter-item expanded "><a href="reverse-engineering/dumb-fuzzing.html"><strong aria-hidden="true">1.3.</strong> Dumb fuzzing</a></li><li class="chapter-item expanded "><a href="reverse-engineering/instrumentation.html"><strong aria-hidden="true">1.4.</strong> Instrumentation</a></li><li class="chapter-item expanded "><a href="reverse-engineering/code-coverage-fuzzing.html"><strong aria-hidden="true">1.5.</strong> Coverage-based fuzzing</a></li><li class="chapter-item expanded "><a href="reverse-engineering/symbolic-execution.html"><strong aria-hidden="true">1.6.</strong> Symbolic execution</a></li><li class="chapter-item expanded "><a href="reverse-engineering/binary-diffing.html"><strong aria-hidden="true">1.7.</strong> Binary diffing</a></li><li class="chapter-item expanded "><a href="reverse-engineering/binary-diffing-tools.html"><strong aria-hidden="true">1.8.</strong> Binary diffing tools</a></li></ol></li><li class="chapter-item expanded "><a href="common-vulnerabilities/common-vulnerabilities.html"><strong aria-hidden="true">2.</strong> Common vulnerabilities</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="common-vulnerabilities/stack-buffer-overflow.html"><strong aria-hidden="true">2.1.</strong> Stack buffer overflow</a></li><li class="chapter-item expanded "><a href="common-vulnerabilities/heap-buffer-overflow.html"><strong aria-hidden="true">2.2.</strong> Heap buffer overflow</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="common-vulnerabilities/house-of-force.html"><strong aria-hidden="true">2.2.1.</strong> House of Force</a></li><li class="chapter-item "><a href="common-vulnerabilities/house-of-orange.html"><strong aria-hidden="true">2.2.2.</strong> House of Orange</a></li><li class="chapter-item "><a href="common-vulnerabilities/single-byte-overflows.html"><strong aria-hidden="true">2.2.3.</strong> Single byte overflows</a></li></ol></li><li class="chapter-item expanded "><a href="common-vulnerabilities/use-after-free.html"><strong aria-hidden="true">2.3.</strong> Use after free</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="common-vulnerabilities/fastbin-dup.html"><strong aria-hidden="true">2.3.1.</strong> Fastbin dup</a></li><li class="chapter-item "><a href="common-vulnerabilities/unsortedbin-attack.html"><strong aria-hidden="true">2.3.2.</strong> Unsortedbin attack</a></li></ol></li><li class="chapter-item expanded "><a href="common-vulnerabilities/heap-grooming.html"><strong aria-hidden="true">2.4.</strong> Heap grooming</a></li><li class="chapter-item expanded "><a href="common-vulnerabilities/race-conditions.html"><strong aria-hidden="true">2.5.</strong> Race conditions</a></li></ol></li><li class="chapter-item expanded "><a href="exploit-primitives/exploit-primitives.html"><strong aria-hidden="true">3.</strong> Exploit primitives</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exploit-primitives/arbitrary-write-primitives.html"><strong aria-hidden="true">3.1.</strong> Arbitrary write primitives</a></li><li class="chapter-item expanded "><a href="exploit-primitives/relative-write-primitives.html"><strong aria-hidden="true">3.2.</strong> Relative write primitives</a></li><li class="chapter-item expanded "><a href="exploit-primitives/arbitrary-read-primitives.html"><strong aria-hidden="true">3.3.</strong> Arbitrary read primitives</a></li><li class="chapter-item expanded "><a href="exploit-primitives/chaining-primitives.html"><strong aria-hidden="true">3.4.</strong> Chaining primitives</a></li><li class="chapter-item expanded "><a href="exploit-primitives/escalating-privileges.html"><strong aria-hidden="true">3.5.</strong> Escalating privileges</a></li></ol></li><li class="chapter-item expanded "><a href="return-oriented-programming/return-oriented-programming.html"><strong aria-hidden="true">4.</strong> Return oriented programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="return-oriented-programming/aslr-nx.html"><strong aria-hidden="true">4.1.</strong> ASLR/NX</a></li><li class="chapter-item expanded "><a href="return-oriented-programming/finding-gadgets.html"><strong aria-hidden="true">4.2.</strong> Finding gadgets</a></li><li class="chapter-item expanded "><a href="return-oriented-programming/calling-libc-functions-and-syscalls.html"><strong aria-hidden="true">4.3.</strong> Calling libc functions and syscalls</a></li><li class="chapter-item expanded "><a href="return-oriented-programming/chaining-gadgets-to-execute-code.html"><strong aria-hidden="true">4.4.</strong> Chaining gadgets to execute code</a></li><li class="chapter-item expanded "><a href="return-oriented-programming/executing-arbitrary-shellcode.html"><strong aria-hidden="true">4.5.</strong> Executing arbitrary shellcode</a></li></ol></li><li class="chapter-item expanded "><a href="exploit-mitigations/exploit-mitigations.html"><strong aria-hidden="true">5.</strong> Exploit mitigations</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="exploit-mitigations/aslr.html"><strong aria-hidden="true">5.1.</strong> Address Space Layout Randomization (ASLR)</a></li><li class="chapter-item expanded "><a href="exploit-mitigations/dep.html"><strong aria-hidden="true">5.2.</strong> Data Execution Prevention (DEP)/NX</a></li><li class="chapter-item expanded "><a href="exploit-mitigations/position-independent-executables.html"><strong aria-hidden="true">5.3.</strong> Position Independent Executables (PIEs)</a></li><li class="chapter-item expanded "><a href="exploit-mitigations/exploiting-pies.html"><strong aria-hidden="true">5.4.</strong> Exploiting PIEs</a></li><li class="chapter-item expanded "><a href="exploit-mitigations/stack-canaries.html"><strong aria-hidden="true">5.5.</strong> Stack canaries</a></li><li class="chapter-item expanded "><a href="exploit-mitigations/safe-list-unlinking.html"><strong aria-hidden="true">5.6.</strong> Safe list unlinking</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to the Dark Arts</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="bonsoir"><a class="header" href="#bonsoir">Bonsoir</a></h1>
<p>This <code>mdBook</code> contains notes from my self-study of binary exploitation and
reverse-engineering. If you have any questions about the contents within, you
can find my contact information <a href="https://one2bla.me">on my website</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reverse-engineering"><a class="header" href="#reverse-engineering">Reverse engineering</a></h1>
<p>In this section, you'll find my notes on reverse engineering. This includes
discussions on the following topics:</p>
<ul>
<li>Static reverse engineering</li>
<li>Dynamic reverse engineering</li>
<li>Instrumentation</li>
<li>Fuzzing</li>
<li>Symbolic execution</li>
<li>Concolic execution</li>
<li>Binary diffing</li>
<li>Binary diffing tools</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-reverse-engineering"><a class="header" href="#static-reverse-engineering">Static reverse engineering</a></h1>
<p>Reverse engineers use static reverse engineering to inspect programs at rest,
meaning not loaded into memory or currently executing. Reverse engineers
utilize a series of tools to statically inspect a program in order to derive
its purpose and functionality. Starting at the shallow end of analysis, the
following tools are useful for static reverse engineering:</p>
<ul>
<li><code>strings</code> - the strings utility outputs all printable character sequences
that are at least 4 characters long for a given file. This tool is useful for
reverse engineers as it provides an initial peek at what functionality might
exist within the target program.</li>
<li><code>file</code> - the file utility gives a best-effort determination of what type of
file the reverse engineer is inspecting. <code>file</code> looks for common ASCII strings,
but also checks a file to see if it contains data structured according to known
file formats like ELFs.</li>
<li><code>PEiD</code> - a Windows tool that's useful for identifying the compiler used to
build a Windows PE and any tools used to obfuscate the PE being inspected.</li>
</ul>
<p>Some tools that provide a little more sophistication for static reverse
engineering are as follows:</p>
<ul>
<li><code>nm</code> - this utility lists the symbols in a provided object file or executable
. Using <code>nm</code> on object files just shows an object file's exported global
varibles and symbols - an executable provides similar output, however, external
functions that the program links against will also be present.</li>
<li><code>ldd</code> - <strong>list dynamic dependencies</strong>, this will list the libraries a
dynamically linked executable uses / expects in order to implement its
functionality.</li>
<li><code>objdump</code> - an extremely versatile utility for ELF inspection, this program
can provide a reverse engineer the following information about a program:
<ul>
<li>Program section headers - a summary of the information for each section in
the program - e.g.: <code>.text</code>, <code>.rodata</code>, <code>.dynamic</code>, <code>.got</code>, <code>.got.plt</code>, etc.</li>
<li>Private headers - program memory layout information and other information
required by the loader, e.g. a list of required libraries - produces similar
output to <code>ldd</code>.</li>
<li>Debugging information</li>
<li>Symbol information</li>
<li>Disassembly listing - <code>objdump</code> performs a <strong>linear sweep disassembly</strong> of
the sections of the file marked as code. <code>objdump</code> outputs a text file of this
listing, commonly known as a <code>dead listing</code>.</li>
</ul>
</li>
<li><code>c++filt</code> - a tool that understands and deciphers the symbol name mangling
scheme of different compilers for C++ applications. Compilers mangle symbol
names with some standardized formatting in order to avoid symbol collisions
of symbols within different namespaces. <code>c++filt</code> not only de-mangles the
symbol output of tools like <code>nm</code> on <code>g++</code> compiled programs, but is also
able to identify and fix paramters passed to previously mangled symbols.</li>
</ul>
<p>Finally, at the deep end of static reverse engineering tools:</p>
<ul>
<li><code>ndisasm</code> - a <strong>stream disassembler</strong>, this utility doesn't require the data
inspected to be a valid program. It just takes a stream of bytes and attempts
to accurately disassemble the bytes to provide readable assembly code. Of
course you'll have to provide <code>ndisasm</code> with the suspected target architecture
and pointer size (32bit or 64bit).</li>
<li><code>IDAPro</code> - created by HexRays, IDAPro is a static reverse engineering tool
that conducts disassembly and decompliation of a target program and uses a
proprietary technology called FLIRT (Fast Library Identification and
Recognition Technology) for standard library function recognition.</li>
<li><code>Ghidra</code> - a crowd favorite, Ghidra is a static reverse engineering tool that
disassembles and decompiles a target program using a <strong>recursive descent</strong>
algorithm. Without going too in depth into the differences between
<strong>linear sweep</strong> and <strong>recursive descent</strong> disassembly, Ghidra follows branches
, functions calls, returns, etc. when disassembling a target binary. This is in
contrast to objump which disassembles blocks of bytes which can be assumed to
be valid instructions. <strong>Recursive descent</strong> disassembly provides the reverse
engineer with more context and usually more accurate results for disassembled
programs.</li>
<li><code>Binary Ninja</code> - created by Vector35 and similar to both IDAPRo and Ghidra,
Binary Ninja is pretty good at providing a high level intermediate language
representation of a target program. Like IDAPro and Ghidra, Binary Ninja allows
reverse engineers to program scripts against its API - this is usually done to
fix known issues with disassembly or provide general quality of life
improvements.</li>
</ul>
<h2 id="pros-of-static-reverse-engineering"><a class="header" href="#pros-of-static-reverse-engineering">Pros of Static Reverse Engineering</a></h2>
<p>Reverse engineers can utilize static reverse engineering to gather information
about a target binary without having to load and execute that binary in memory.
This is most useful when a reverse engineer needs to gather information about
a malicious program but wants to avoid having that malicious program execute
its functionality on the reverse engineer's system. Static reverse engineering
is also useful when the reverse engineer does not have the requisite system(s)
to load and execute a target for dynamic analysis. This scenario is common when
inspecting programs extracted from embedded devices or real-time operating
systems. These programs are usually compiled for a different architecture than
the reverse engineer's machine and expect special / custom devices to be
present in order to implement their functionalities. Static reverse engineering
allows analysts the time and ability to deeply inspect a target program and,
with tools like Ghidra and IDAPro, an analyst can generate and analyze control
flow graphs (CFG)s, data dependencies, decompiled code, etc. Finally, reverse
engineers can easily collaborate when conducting static reverse engineering.
The Ghidra Server is a prime example of this, providing change control for a
repository of programs as analysts comment, label, and update listings.</p>
<h2 id="cons-of-static-reverse-engineering"><a class="header" href="#cons-of-static-reverse-engineering">Cons of Static Reverse Engineering</a></h2>
<p>Try as we might, some things can't be answered by static reverse engineering.
Often times, if the author of a program intends upon protecting their
intellectual property - or if the author is a malware developer - programs can
come packed / compressed. These usually contain a decoder stub that will
unpack the real program to be executed into the process memory. A number of
unpacking programs exist that help reverse engineers get back to statically
analyzing their targets, however, it's possible a paranoid malware author
could invent their own packer / unpacker with custom encryption, etc.</p>
<p>This increase in sophistication requires reverse engineers to conduct deeper
inspection on custom unpacking algorithms written by malware authors. Luckily,
tools like Ghidra, Binary Ninja, and IDAPro provide scripting interfaces that
allow reverse engineers to write and execute custom scripts. This enables
reverse engineers with the ability to operate on the disassembly
programatically, making the unpacking of custom packed malware more feasible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dynamic-reverse-engineering"><a class="header" href="#dynamic-reverse-engineering">Dynamic reverse engineering</a></h1>
<p>Dynamic reverse engineering is utilized by analysts to derive conclusions that
can't be discovered with static reverse engineering. In order to conduct
dynamic reverse engineering, analysts load and execute the program of
inspection (POI) into memory in a controlled environment. Analysts usually
attempt to recreate the exact environment the POI normally executes in order to
remove any variables that might cause differences for exploit development. The
following are some technologies and techniques used to accomplish dynamic
reverse engineering:</p>
<ul>
<li>Containerization - analysts can place POIs into containers using technologies
like Docker. This allows analysts to control the POI's use of system resources
and software packages. Containerization is useful in identifying a POI's
dependencies and enables the recreation of a POI's exploitable environment.
Containers are a excellent choice for quickly creating lightweight, virtualized
environments for dynamic reverse engineering and exploit development.</li>
<li>Virtualization - virtualization technologies like VMware, VirtualBox, and QEMU
allow analysts to create an entire Guest Operating System running the POI's
intended Operating System, managed by a hypervisor on the Host Operating System
. These virtualization technologies are useful for dynamic reverse engineering
because the analyst can control the Guest Operating System's resources, e.g.
network cards, graphics cards, host dynamic memory, disk memory, etc. Full
virtualization also makes virtualization entirely transparent to the Guest
Operating System - all system calls are translated by the hypervisor to the
host machine without the Guest OS's awareness. This is useful for the
inspection of POI's with more sophisticated virtualization detection
mechanisms.</li>
<li>QEMU user-mode emulation - this project recevies its own bullet due to its
usefulness for dynamic reverse engineering. QEMU's user-mode emulation through
programs found in the <code>qemu-user-static</code> package allows analysts to load and
execute programs compiled for different architectures. Not only that, it
provides an easy interface for changing the POIs environment variables, library
loading behavior, system call tracing, and remote debugging. Knowledge and use
of QEMU's user-mode emulation is a must for analysts attempting to reverse
engineer embedded software.</li>
<li>Function call hooking - during dynamic reverse engineering, sometimes
programs execute function calls to external libraries expecting specific
responses in order to continue execution. A majority of the time, analysts are
unable to recreate the correct environment in order to correctly service these
external library function calls, thus the program aborts or exits before
executing any interesting behavior. Analysts combat this by writing hooks in C
and compiling shared objects for dynamically-linked POIs, intercepting a POI's
external library function calls and returning correct values so that the
program can continue execution without failure.</li>
<li>Debugging - with utilities like <code>gdb</code> or <code>windbg</code>, analysts can examine the
process stack, heap, and registers while a POI executes in process memory. This
deep inspection allows analysts to truly understand how a POI behaves, what
return values it expects from internal and external subroutines, and also opens
a window to extracting packed / encrypted programs from process memory after
decoding.</li>
<li>Symbolic execution - symbolic execution, sometimes known as symbolic
analysis, is a technique used to derive the inputs to a program that satisfies
a constraint for a specific path of execution. A symbolic execution engine will
analyze a specific slice of the program and determine what variables are used
to reach a target address. From here, a symbolic execution engine can conduct
&quot;concolic execution&quot;, a term used to describe a mix of symbolic and concrete
execution wherein the engine determines the satisfiability contraints for a
path of execution and tests different inputs to inspect their side effects.
Symbolic analysis has various security applications and use cases for reverse
engineers, enabling them with the ability to find vulnerabilities, generate
exploits, and conduct full code coverage for malware specimens.</li>
</ul>
<h2 id="pros-of-dynamic-reverse-engineering"><a class="header" href="#pros-of-dynamic-reverse-engineering">Pros of Dynamic Reverse Engineering</a></h2>
<p>Reverse engineers can utilize dynamic reverse engineering to answer questions
that can't be satisfied by static reverse engineering. In addition, dynamic
reverse engineering allows analysts to understand the behavior of programs that
have been packed or encrypted, allowing them to unpack or decrypt themselves
prior to being loaded into memory by the decompression / decoder stub of the
program. Using this technique, analysts can dump the program from process
memory onto the disk for further static analysis.</p>
<p>During dynamic reverse engineering, analysts can gradually provide POIs with
necessary resources to inspect behavioral changes. This technique is most
commonly used with programs that receive command and control (C2)
communications from a source on the Internet - allowing POIs to have access to
a network card within a controlled environment.</p>
<p>Dynamic reverse engineering allows analysts to understand the true intent of a
POI, if it wasn't already readily apparent during static analysis. Because most
analysis occurs within a virtual environment, an analyst can execute the
program without risk to lab infrastructure or information - this is useful for
the inspection of malware like ransomware, wipers, worms, etc.</p>
<h2 id="cons-of-dynamic-reverse-engineering"><a class="header" href="#cons-of-dynamic-reverse-engineering">Cons of Dynamic Reverse Engineering</a></h2>
<p>There will always be inherent risk in executing code that you didn't write
yourself. It's entirely possible that a POI utilizes some undisclosed jailbreak
/ sandbox escape that could cause harm to the analyst's workstation. In
addition, most malware today comes with functionality to detect virtualization
or debugging techniques. Some malware even goes so far as to report an
analyst executing the malware within a sandbox environment - alerting the
malware author to update or change the program distribution to hamper
reverse engineering efforts.</p>
<p>Despite all best efforts, sometimes it will be impossible to recreate the POIs
operating environment. Using dynamic reverse engineering, analysts have to make
assumptions that might not always be correct - this can cause analysts to focus
on unimportant features of the POI or paths of execution that may never take
place in the real environment.</p>
<p>Virtualization for dynamic reverse engineering also has its limitations. A
prime example of this is the Spectre security vulnerability. <a href="reverse-engineering/dynamic-reverse-engineering.html#references">[1]</a>
This vulnerability affects modern processors that perform branch prediction -
attackers can leverage the side effects of speculative execution and branch
misprediction to reveal private data. It would be infeasible for a reverse
engineer to inspect a malware specimen exploiting this vulnerability from a
virtualized environment. Likely, the reverse engineer would have to conduct
debugging and analysis on a physical processor.</p>
<h1 id="references"><a class="header" href="#references">References</a></h1>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)">https://en.wikipedia.org/wiki/Spectre_(security_vulnerability)</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dumb-fuzzing"><a class="header" href="#dumb-fuzzing">Dumb fuzzing</a></h1>
<h2 id="foreword"><a class="header" href="#foreword">Foreword</a></h2>
<p>Before we begin our discussion on fuzzing techniques, note that the terms and
definitions used by different fuzzing publications, tools, etc. are not
congruent. Currently, there doesn't seem to be a standard language when
discussing ideas and concepts related to fuzzing - every blog or article is
using terms and definitions differently.</p>
<p>Because of this, all of the language we will use for this and future
discussions on fuzzing will be derived from <a href="reverse-engineering/dumb-fuzzing.html#references">[1]</a>. It's an
excellent resource that pulls together the most popular fuzzing tools and
publications and attempts to standardize our understanding of the fuzzing
process as well as all of the terms and techniques associated with fuzzing.</p>
<h2 id="model-less-fuzzing-dumb-fuzzing"><a class="header" href="#model-less-fuzzing-dumb-fuzzing">Model-less fuzzing (dumb fuzzing)</a></h2>
<p>Fuzzers are used to generate input for <strong>programs under test (PUTs)</strong>,
attempting to find inputs that crash the program - a crash being some sort of
unrecoverable state like a segmentation fault. Being programmers ourselves, we
understand that most programs have vulnerabilities in only very specifc
sections of code, requiring specific inputs to traverse an execution path that
reaches the vulnerable code.</p>
<p><strong>Model-less fuzzers</strong>, or dumb fuzzers, generate input data for PUTs without
any knowledge of the structure required for the data expected by the PUT. A
good example provided by <a href="reverse-engineering/dumb-fuzzing.html#references">[1]</a> is the fuzzing of an MP3 player
application. MP3 files have a particular structure that needs to be met and, if
the MP3 player application is provided an invalid file, it will exit without
executing further code. In this example, unless the model-less fuzzer is
provided with some initial <strong>seed</strong> data, the model-less fuzzer will be unable
to traverse further execution paths until it correctly guesses the data
structure expected by the MP3 player application - this is an infeasible
approach to exploitation.</p>
<p>Model-less fuzzers are <strong>mutation-based</strong>, all of the input they generate for
PUTs is based off of a set of <strong>seeds</strong> provided by the researcher. <strong>Seeds</strong>
are input data that can be correctly ingested by the PUT and allows the fuzzer
to reach sections of code that are usually executed after the input data
is validated. Seeds are usually derived from real-world application use. Once
the model-less fuzzer is provided with enough seeds, the fuzzer will generate
<strong>mutations</strong> of the seeds as test cases for the PUT.</p>
<h3 id="bit-flipping"><a class="header" href="#bit-flipping">Bit-Flipping</a></h3>
<p><strong>Bit-flipping</strong> is a common technique used by model-less fuzzers to mutate
seeds and generate test cases for PUTs. The fuzzer flips a number of bits in
the seed, whether it be random or configurable is determined by the
implementation of the fuzzer. Bit-flipping, model-less fuzzers that allow
user-configuration usually employ a configuration parameter called the
<strong>mutation ratio</strong>, a ratio defined as <code>K</code> random bits in an <code>N-bit</code> seed:
<code>K/N</code>.</p>
<h3 id="arithmetic-mutation"><a class="header" href="#arithmetic-mutation">Arithmetic Mutation</a></h3>
<p><strong>Arithmetic mutation</strong> is a mutation operation where a selected byte sequence
is treated as an integer and simple arithmetic is performed on it by the
fuzzer. For instance, AFL selects a 4-byte value from a seed and then replaces
the integer within that seed with a value <code>+/-</code> some random, small number <code>r</code>.</p>
<h3 id="block-based-mutation"><a class="header" href="#block-based-mutation">Block-based mutation</a></h3>
<p><strong>Block-based mutation</strong> involves:</p>
<ul>
<li>Inserting a randomly generated block of bytes into a random position in a
seed.</li>
<li>Deleting a randomly selected block of bytes from a seed.</li>
<li>Replacing a randomly selected block of bytes with a random value in a seed.</li>
<li>Generating random permutations for the order of blocks in a seed.</li>
<li>Resizing seeds by appending random blocks.</li>
<li>Randomly switching blocks of different seeds.</li>
</ul>
<h3 id="dictionary-based-mutation"><a class="header" href="#dictionary-based-mutation">Dictionary-based mutation</a></h3>
<p><strong>Dictionary-based mutation</strong> involves a fuzzer using a set of pre-defined
values with significant semantic weight, for example <code>0</code>,<code>-1</code>, or format
strings, for mutation.</p>
<h2 id="feedback-and-evaluation"><a class="header" href="#feedback-and-evaluation">Feedback and evaluation</a></h2>
<p>So how does a fuzzer detect the discovery of an interesting input? Model-based
and model-less fuzzers both leverage the use of <strong>bug oracles</strong> for input
evaluation. A <strong>bug oracle</strong> is a part of the fuzzer that determines whether
a given execution of the PUT violates a specific security policy. Usually, bug
oracles are designed to detect segmentation faults but, with the implementation
of sanitizers, fuzzers can also detect unsafe memory accesses, violations of
control flow integrity, and other undefined behaviors.</p>
<h2 id="problems-with-model-less-fuzzing"><a class="header" href="#problems-with-model-less-fuzzing">Problems with model-less fuzzing</a></h2>
<p>A practical challenge that model-less, mutation-based fuzzing faces is a
program's use of checksum validation, a primary example being the use of a
<strong>cyclic redundancy check (CRC)</strong>. A CRC is an error-detecting code that
ensures that the integrity of the data contained in the input file is preserved
during transmission. If a PUT computes the checksum of an input before parsing
it, it's highly likely that most of the test input provided by the fuzzer will
be rejected.</p>
<p>In this case, model-base fuzzing of the PUT is more likely to succeed, as
showcased in Experiment 2 of <a href="reverse-engineering/dumb-fuzzing.html#references">[2]</a>. During the experiment, the
model-based fuzzer had full knowledge of how the input data was to be
structured, including how the checksum was generated. This allowed the fuzzer
to achieve greater code coverage than any of the model-less, mutation-based
fuzzer implementations.</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ol>
<li><a href="https://arxiv.org/pdf/1812.00140.pdf">https://arxiv.org/pdf/1812.00140.pdf</a></li>
<li><a href="https://www.ise.io/wp-content/uploads/2019/11/cmiller_defcon2007.pdf">https://www.ise.io/wp-content/uploads/2019/11/cmiller_defcon2007.pdf</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instrumentation"><a class="header" href="#instrumentation">Instrumentation</a></h1>
<p>Before we begin a discussion on instrumentation, let's define the different
types of fuzzing because they can be categorized based upon the amount of
instrumentation they leverage.</p>
<h3 id="black-box-fuzzers"><a class="header" href="#black-box-fuzzers">Black-box fuzzers</a></h3>
<p><strong>Black-box fuzzers</strong> use fuzzing techniques that do not see the internals of
<strong>programs under test (PUTs)</strong>. Black-box fuzzers make decisions upon the
input/output behavior of the PUT. These types of fuzzers are colloquially
called IO-driven or data-driven in the software testing community.
<a href="reverse-engineering/instrumentation.html#references">[1]</a></p>
<h3 id="white-box-fuzzers"><a class="header" href="#white-box-fuzzers">White-box fuzzers</a></h3>
<p><strong>White-box fuzzers</strong> generate test cases by analyzing the internals of a PUT,
exploring the state space of the PUT systematically. White-box fuzzing is also
called dynamic symbolic execution or <strong>concolic testing</strong> (concrete + symbolic)
. What this basically means is that the fuzzer leverages concrete and symbolic
execution simultaneously, using concrete program states to simplify symbolic
constraints. <a href="reverse-engineering/instrumentation.html#references">[1]</a></p>
<h3 id="grey-box-fuzzers"><a class="header" href="#grey-box-fuzzers">Grey-box fuzzers</a></h3>
<p><strong>Grey-box fuzzers</strong> are able to obtain <em>some</em> information about a PUT and its
executions. In contrast with white-box fuzzers, grey-box fuzzers only perform
lightweight static analysis on the PUT and gather dynamic information during
program execution such as code coverage - they utilize approximate information
in order to speed up the rate of testing. <a href="reverse-engineering/instrumentation.html#references">[1]</a></p>
<h2 id="instrumentation-1"><a class="header" href="#instrumentation-1">Instrumentation</a></h2>
<p>Grey and white-box fuzzers instrument the PUT to gather feedback for each
execution of the program. Black-box fuzzers don't leverage any instrumentation
so they won't be discussed in this section. What is instrumentation?
<a href="reverse-engineering/instrumentation.html#references">[1]</a> defines two categories:</p>
<ul>
<li><strong>Static program instrumentation</strong> - instrumentation of a PUT before it is
executed. This is usually done at compile time on either source code or an
intermediate representation. An good example is how AFL instruments every
branch instruction of a PUT in order to compute branch coverage. This feedback
allows AFL to choose test cases that are more likely to traverse more or newer
branches of a PUT.</li>
<li><strong>Dynamic program instrumentation</strong> - instrumentation of a PUT while the
program is being executed. Dynamic instrumentation provides the advantage of
easily instrumenting dynamically linked libraries because the instrumentation
is performed at runtime. Leveraging dynamic program instrumentation provides a
fuzzer with a more complete picture of code coverage as its able to obtain
information from external libraries.</li>
</ul>
<h2 id="so-how-does-this-aid-fuzzers"><a class="header" href="#so-how-does-this-aid-fuzzers">So how does this aid fuzzers?</a></h2>
<p>As stated earlier, instrumentation provides execution feedback to grey and
white-box fuzzers, providing the fuzzers with information useful for making
decisions on which seeds to prioritize for the generation of input data.
Fuzzers leverage feedback from instrumented PUTs to generate statistics and
track which portions of the code have been traversed and which execution paths
are most likely to produce a crash.</p>
<p>Instrumentation also aids fuzzers through in-memory fuzzing.
<strong>In-memory fuzzing</strong> is when a fuzzer only tests a portion of the PUT without
respawning the process for each fuzz iteration. This is often useful for large
applications that use a GUI and often need time to execute a significant amount
of initialization code. The fuzzer can take a memory snapshot of the PUT right
after it has been initialized and then utilize this memory snapshot to begin
the fuzzing campaign. Instrumentation used in this manner increases the speed
in which a fuzzer can execute test cases to find crashing input.</p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ol>
<li><a href="https://arxiv.org/pdf/1812.00140.pdf">https://arxiv.org/pdf/1812.00140.pdf</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coverage-based-fuzzing"><a class="header" href="#coverage-based-fuzzing">Coverage-based fuzzing</a></h1>
<p>We've somewhat discussed code-coverage based fuzzing in the previous sections
when talking about grey-box testing or the AFL fuzzer, but here we'll actually
provide a concrete definition, some examples, and references.</p>
<p><strong>Code-coverage based fuzzing</strong> is a technique that programmers and fuzzers use
in order to uncover as many bugs as possible within a program. In previous
sections we talked about mutation-based fuzzing and generating random input
with dumb fuzzers in an attempt to generate a crash, but those techniques
aren't super helpful if the program never uses all of its code to evaluate our
input. Code-coverage based fuzzing solves this argument, the more code we
execute within a program the more likely we are to find a bug.</p>
<h2 id="examples-and-resources"><a class="header" href="#examples-and-resources">Examples and resources</a></h2>
<h3 id="the-fuzzing-book"><a class="header" href="#the-fuzzing-book">The Fuzzing Book</a></h3>
<p>First I'll start with the <a href="reverse-engineering/code-coverage-fuzzing.html#references">The Fuzzing Book's</a> article on
code-coverage based fuzzing. This article explains code-coverage based fuzzing
in depth and provides examples for Python and C applications. The article
conducts code-coverage based fuzzing for a CGI decoding application, an
application that takes URL encoded strings and reverts them to their original
text.</p>
<p>In this article, the author also takes the time to make the distinction between
black-box fuzzing and white-box fuzzing, and how white-box fuzzing enables
code-coverage based fuzzing. Without <a href="reverse-engineering/./instrumentation.html">instrumentation</a>, we
aren't able    to conduct code-coverage based fuzzing because the fuzzer doesn't
have the ability to capture which lines of code have been executed by the
<strong>program under test (PUT)</strong>. With instrumentation, however, we can conduct
code-coverage based fuzzing for both program statements and branch
instructions.</p>
<p>In this particular example, the author uses statement-based coverage to acquire
code-coverage fuzzing statistics. Because the decoder application is so small,
the author only needed to run ~40-60 fuzzing iterations to cover all lines of
code in the application.</p>
<h3 id="fuzzing-with-code-coverage-by-example"><a class="header" href="#fuzzing-with-code-coverage-by-example">Fuzzing with Code Coverage by Example</a></h3>
<p><a href="reverse-engineering/code-coverage-fuzzing.html#references">This presentation</a> given by Charlie Miller at Toorcon 2007
provides some good historical context and expands upon the advancements made
towards mutation-based, generation-based, and code-coverage based fuzzing. It's
a thorough explanation with some great examples and pratical exercises for
code-coverage based fuzzing. The most interesting part is its mention of
evolutionary algorithms for code-coverage based fuzzing, and how mutation-based
, model-less fuzzers can utilize the feedback provided by code-coverage based
fuzzing to select more &quot;fit&quot; inputs.</p>
<h3 id="fuzzing-by-suman-jana"><a class="header" href="#fuzzing-by-suman-jana">Fuzzing by Suman Jana</a></h3>
<p><a href="reverse-engineering/code-coverage-fuzzing.html#references">This presentation</a> by Suman Jana from Columbia University in the
City of New York, provides a more recent synopsis of code-coverage based
fuzzing. This presentation covers one of the more popular fuzzers in the
research community that uses code-coverage based fuzzing,
<strong>American Fuzzy Lop (AFL)</strong>. AFL is a model-less, mutation-based, grey-box
fuzzer that leverages instrumentation at compile time to conduct branch-based
code-coverage fuzzing. Throughout a fuzzing campaign, AFL will use its
instrumentation to evaluate what branches a particular seed was able to cover.
AFL attempts to generate a pool of seeds that cover as much of the program as
possible, and also trims seeds from the pool to produce the minimum required
input to cover sections of code.</p>
<h2 id="evolutionary-algorithms"><a class="header" href="#evolutionary-algorithms">Evolutionary Algorithms</a></h2>
<p>An <strong>Evolutionary Algorithm (EA)</strong> uses biological evolution mechanisms such as
mutation, recombination, and selection to maintain a <strong>seed pool</strong> of &quot;fit&quot;
input candidates for a fuzzing campaign, and new candidates can be discovered
and added to this seed pool as more data is collected. Most grey-box fuzzers
leverage EAs in tandem with node or branch coverage to generate seeds,
preserving seeds that discover new nodes or branches and trimming seeds until
the minimum amount of input required to cover a branch is discovered. The
implementations of EAs across different grey-box fuzzers varies, but they all
end up achieving similar goals using this feedback mechanism.
<a href="reverse-engineering/code-coverage-fuzzing.html#references">[4]</a></p>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<ol>
<li><a href="https://www.fuzzingbook.org/html/Coverage.html#">https://www.fuzzingbook.org/html/Coverage.html#</a></li>
<li><a href="https://www.ise.io/wp-content/uploads/2019/11/cmiller_toorcon2007.pdf">https://www.ise.io/wp-content/uploads/2019/11/cmiller_toorcon2007.pdf</a></li>
<li><a href="https://www.cs.columbia.edu/%7Esuman/secure_sw_devel/fuzzing.pdf">https://www.cs.columbia.edu/~suman/secure_sw_devel/fuzzing.pdf</a></li>
<li><a href="https://arxiv.org/pdf/1812.00140.pdf">https://arxiv.org/pdf/1812.00140.pdf</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="symbolic-execution"><a class="header" href="#symbolic-execution">Symbolic execution</a></h1>
<p><strong>Symbolic execution</strong> is a program analysis technique that can be used to
determine what concrete values are required to cause different parts of a
program to execute. It's goals are similar to code-coverage based fuzzing,
however, it's different because it's not generating and mutating a bunch of
concrete input and throwing it at the program until it reaches a new execution
path or branch.</p>
<p>Symbolic execution analyzes a program and assigns symbolic values to all
expressions that cause conditional branches within a program. A symbolic
execution engine maintains and generates <strong>path conditions</strong> using these
symbols and expressions, providing the researcher with a symbolic
representation of how to reach different execution paths within the program.</p>
<p>Symbolic execution engines also utilize <strong>model checkers</strong>, taking the
generated path conditions for each execution path and leveraging a
<strong>satisifiability modulo theories (SMT)</strong> solver, or constraint solver, to
calculate the concrete values that satisfy the formulas represented by each
path condition. <a href="reverse-engineering/symbolic-execution.html#references">[1]</a></p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Here's an example from a presentation on symbolic execution from the
University of Maryland <a href="reverse-engineering/symbolic-execution.html#references">[2]</a>:</p>
<p><img src="reverse-engineering/./symbolic_execution_example.png" alt="symbolic_execution_example" /></p>
<p>This example provides the reader with a solid breakdown of how path conditions
are generated for different paths of execution in a small snippet of code. The
symbolic execution engine will provide to the tester what conditions need to be
true for the <code>assert</code> call to fail. From there, the engine can also derive
concrete values for each symbol that will cause the program to fail the
assertion.</p>
<h2 id="concolic-execution"><a class="header" href="#concolic-execution">Concolic execution</a></h2>
<p>Dynamic symbolic execution or <strong>concolic execution</strong> is a form of white-box
fuzzing that conducts symbolic execution while the program is being executed
with concrete values. Like we discussed earlier, this form of white-box fuzzing
is possible through <a href="reverse-engineering/./instrumentation.html">instrumentation</a> of the PUT. The
symbolic execution engine is able to recieve feedback on the concrete input it
provides to the PUT allowing it to derive symbolic constraints for different
paths of execution more efficiently. The algorithm for concolic execution is
actually explained pretty well in the concolic testing Wikipedia article.
<a href="reverse-engineering/symbolic-execution.html#references">[3]</a>.</p>
<h2 id="applications"><a class="header" href="#applications">Applications</a></h2>
<p>Symbolic execution is useful for software verification and testing because,
unlike static analysis tools, symbolic execution will never produce false
positives for software errors. Symbolic execution is useful for software
engineering because its final product is a concrete input that will cause the
<strong>program under test (PUT)</strong> to fail a specification. Various different
symbolic execution engines and tools have been used across the industry by
software engineers and hackers alike to find security vulnerabilities.</p>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<p>There are some properties of programs that can hinder program analysis using
symbolic execution. A quick listing and short description of these limitations
referencing <a href="reverse-engineering/symbolic-execution.html#references">[1]</a> can be found below:</p>
<ul>
<li><strong>Memory</strong> - symbolic execution engines have a hard time handling pointers,
arrays, and other complex objects like the contents of data structures stored
on the heap.</li>
<li><strong>Environment</strong> - symbolic execution engines don't account for things like
calls to other libraries, file system operations, etc. A symbolic execution
engine could be testing path conditions that contain file operations for some
static filename. Unlike the tests being conducted by the engine, the state of
the file is permanent and thus, if the contents of the file are used for
conditional branches or expressions, this could cause non-deterministic
outcomes for different tests conducted by the engine.</li>
<li><strong>Path explosion</strong> - symbolic execution engines don't scale well when testing
large programs - the number of feasible paths in a program grows exponentially
with program size. The number of feasible paths tracked by an engine can also
become infinite given some loop exists within the program that contains an
unbounded number of iterations.</li>
</ul>
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<ol>
<li><a href="https://arxiv.org/pdf/1610.00502.pdf">https://arxiv.org/pdf/1610.00502.pdf</a></li>
<li><a href="https://www.cs.umd.edu/%7Emwh/se-tutorial/symbolic-exec.pdf">https://www.cs.umd.edu/~mwh/se-tutorial/symbolic-exec.pdf</a></li>
<li><a href="https://en.wikipedia.org/wiki/Concolic_testing">https://en.wikipedia.org/wiki/Concolic_testing</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-diffing"><a class="header" href="#binary-diffing">Binary diffing</a></h1>
<p><strong>Binary diffing</strong> or patch diffing is a technique that compares two binaries
derived from the same code with the goal of discovering their differences and
revealing any technical details that weren't covered in the changelogs,
bulletins, or patch notes for an update. Researchers use binary diffing to
compare known-vulnerable binaries to post-patch binaries in an attempt to suss
out how a vulnerability was patched by the author. It's common for researchers
to also find a way around a discovered patch or the patch can also expose other
vulnerabilities within the binary that were previously overlooked.</p>
<p>Vulnerabilities discovered through binary diffing are colloquially termed
<strong>1-day</strong> bugs / vulnerabilities as they are usually discovered the day after a
patch is released. 1-day bugs can be used to exploit and compromise users or
organizations that are slow to adopt the newest security patches.</p>
<p>Binary diffing is also useful for discovering security patches within entire
code cores for products. In the case of
<a href="reverse-engineering/binary-diffing.html#references">this Google Project Zero article</a>, the researcher leverages
binary diffing to discover kernel memory disclosure bugs in the Windows
operating system core - bugs that can be useful to defeat kernel ASLR in other
exploits.</p>
<h2 id="limitations-1"><a class="header" href="#limitations-1">Limitations</a></h2>
<p>Most of the examples online that aim to teach binary diffing use simple
programs with small changes, however, in real-world scenarios binary differs do
face some obstacles. Here are a few examples as listed by an Incibe-Cert
article on binary diffing <a href="reverse-engineering/binary-diffing.html#references">[2]</a>:</p>
<ul>
<li><strong>Unrelated differences</strong> - it's common that changes in the compiler or
compiler optimizations can cause small differences to manifest between two
different binaries. A security researcher must be able to identify when a
difference between two binaries is unrelated to a patch.</li>
<li><strong>Bugfixes not related to a vulnerability</strong> - sometimes bugfixes are present
in a new version of the binary that are completely unrelated to the
vulnerability of interest.</li>
<li><strong>Obfuscation and anti-diffing techniques</strong> - some authors and organizations
purposefully obfuscate and leverage anti-diffing techniques for patches to
prevent researchers from finding vulnerabilities or reverse-engineering patches
to previous vulnerabilities. <a href="reverse-engineering/binary-diffing.html#references">This BlackHat 2009 presentation</a> by
Jeongwook Oh goes into great detail about binary diffing and various
obfuscation and anti-diffing technologies.</li>
</ul>
<h2 id="references-5"><a class="header" href="#references-5">References</a></h2>
<ol>
<li><a href="https://googleprojectzero.blogspot.com/2017/10/using-binary-diffing-to-discover.html">https://googleprojectzero.blogspot.com/2017/10/using-binary-diffing-to-discover.html</a></li>
<li><a href="https://www.incibe-cert.es/en/blog/importance-of-language-binary-diffing-and-other-stories-of-1day">https://www.incibe-cert.es/en/blog/importance-of-language-binary-diffing-and-other-stories-of-1day</a></li>
<li><a href="https://www.blackhat.com/presentations/bh-usa-09/OH/BHUSA09-Oh-DiffingBinaries-SLIDES.pdf">https://www.blackhat.com/presentations/bh-usa-09/OH/BHUSA09-Oh-DiffingBinaries-SLIDES.pdf</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-diffing-tools"><a class="header" href="#binary-diffing-tools">Binary diffing tools</a></h1>
<h2 id="diaphora"><a class="header" href="#diaphora">Diaphora</a></h2>
<p><a href="reverse-engineering/binary-diffing-tools.html#references">Diaphora</a>, Greek for &quot;difference&quot;, is a binary diffing project
and tool started by <a href="http://www.joxeankoret.com/">Joxean Koret</a>, originally
released in 2015. Diaphora is advertised as the most advanced binary diffing
tool that works as an IDA Pro plugin. <a href="reverse-engineering/binary-diffing-tools.html#references">IDA Pro</a> is a licensed
disassembler and debugger for state-of-the-art binary code analysis.</p>
<p>Diaphora features all of the common binary diffing techniques such as:</p>
<ul>
<li>Diffing assembler.</li>
<li>Diffing control flow graphs.</li>
<li>Porting symbol names and comments.</li>
<li>Adding manual matches.</li>
<li>Similarity ratio calculation.</li>
<li>Batch automation.</li>
<li>Call graph matching calculation.</li>
</ul>
<p>And it also comes with many more advanced features listed in its <code>README.md</code>.
An IDA Pro license comes at a hefty price, however, the contributors to
Diaphora have advertised that support for Ghidra and Binary Ninja are being
actively developed. <a href="reverse-engineering/binary-diffing-tools.html#references">Ghidra</a> is a free software reverse
engineering suite of tools developed by the National Security Agency (NSA).
<a href="reverse-engineering/binary-diffing-tools.html#references">Binary Ninja</a> is another licensed reversing platform developed by
Vector 35.</p>
<h2 id="bindiff"><a class="header" href="#bindiff">Bindiff</a></h2>
<p><a href="reverse-engineering/binary-diffing-tools.html#references">Bindiff</a> is another binary diffing tool developed by Zynamics and
works as a plugin for IDA Pro, as well. Here are some of its use cases as
advertised on their web page:</p>
<ul>
<li>Compare binary files for x86, MIPS, ARM, PowerPC, and other architectures
supported by IDA Pro.</li>
<li>Identify identical and similar functions in different binaries.</li>
<li>Port function names, anterior and posterior comment lines, standard comments
and local names from one disassembly to the other.</li>
<li>Detect and highlight changes between two variants of the same function.</li>
</ul>
<p>It's not all about IDA Pro; As of March 1, 2020, Zynamics released Bindiff 6
which provides experimental support for Ghidra. Open-source research has been
conducted to generate a plugin for these new features and a plugin called
<a href="reverse-engineering/binary-diffing-tools.html#references">BinDiffHelper</a> is currently available that aims to provide
easy-to-use support for Bindiff 6 with Ghidra.</p>
<h2 id="radiff2"><a class="header" href="#radiff2">Radiff2</a></h2>
<p><a href="reverse-engineering/binary-diffing-tools.html#references">Radiff2</a> is Radare2's binary diffing utility.
<a href="reverse-engineering/binary-diffing-tools.html#references">Radare2</a> is a rewrite from scratch of Radare in order to provide
a set of libraries and tools to work with binary files. The Radare project
started as a forensics tool, a scriptable command-line hexadecimal editor able
to open disk files, but later added support for analyzing binaries,
disassembling code, debugging programs, attaching to remote gdb servers, and
so on.</p>
<p>Radiff2 is open-source and attempts to provide the same utility and
functionality as the binary diffing tools listed above without having to cater
to licensed tools like IDA Pro and Binary Ninja.</p>
<h2 id="references-6"><a class="header" href="#references-6">References</a></h2>
<ol>
<li><a href="https://github.com/joxeankoret/diaphora">https://github.com/joxeankoret/diaphora</a></li>
<li><a href="https://www.hex-rays.com/products/ida/">https://www.hex-rays.com/products/ida/</a></li>
<li><a href="https://ghidra-sre.org/">https://ghidra-sre.org/</a></li>
<li><a href="https://binary.ninja/">https://binary.ninja/</a></li>
<li><a href="https://www.zynamics.com/bindiff.html">https://www.zynamics.com/bindiff.html</a></li>
<li><a href="https://github.com/ubfx/BinDiffHelper">https://github.com/ubfx/BinDiffHelper</a></li>
<li><a href="https://r2wiki.readthedocs.io/en/latest/tools/radiff2/">https://r2wiki.readthedocs.io/en/latest/tools/radiff2/</a></li>
<li><a href="https://github.com/radareorg/radare2">https://github.com/radareorg/radare2</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-vulnerabilities"><a class="header" href="#common-vulnerabilities">Common vulnerabilities</a></h1>
<p>In this section, you'll find my notes on common vulnerabilities that you may
find during reverse engineering and how to exploit them. This includes
discussions on the following topics:</p>
<ul>
<li>Stack buffer overflows</li>
<li>Heap buffer overflows</li>
<li>Use after free</li>
<li>Heap grooming</li>
<li>Race conditions</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-buffer-overflow"><a class="header" href="#stack-buffer-overflow">Stack buffer overflow</a></h1>
<h2 id="the-stack"><a class="header" href="#the-stack">The stack</a></h2>
<p>Before we talk about overflowing data structures on the stack, let's define
what the stack is.</p>
<p>The stack is a data structure with two principal operations, <code>push</code> and <code>pop</code>.
The stack follows a <strong>last in, first out (LIFO)</strong> convention meaning the
top-most element of the stack is the first to be removed from the data
structure when a <code>pop</code> operation occurs. Newer values are <code>push</code>ed to the top
of the stack and cannot be removed until succeeding values are <code>pop</code>ed from the
stack. <a href="common-vulnerabilities/stack-buffer-overflow.html#references">[1]</a></p>
<p>The rest of our discussion is related to the <strong>process stack</strong> of ELF binaries.
Each process has a contiguous segment of memory that is set aside to store
information about the active subroutines of the program. The initial stack
layout provides the process access to the command line arguments and
environment used when executing the program. An example of the initial process
stack can be found below <a href="common-vulnerabilities/stack-buffer-overflow.html#references">[2]</a>:</p>
<pre><code class="language-c">argc            // argument count (int)
argv[0]         // program name (char*)
argv[1]         // program arguments (char*)
...
argv[argc-1]
NULL            // end of arguments (void*)
env[0]          // environment (char*)
...
env[n]
NULL            // end of environment (void*)
</code></pre>
<p>The stack can be implemented to grow down (towards lower memory addresses) or
up (towards higher memory addresses). Most common stack implementations grow
downwards as data is <code>push</code>ed to the stack and this is what we will use for
this discussion. A register called the <strong>stack pointer</strong> is used to track
the last address of the stack, the most recent element <code>push</code>ed to the stack.
Many compilers also use a second register, the <strong>frame pointer</strong>, to reference
local variables and parameters passed to functions.</p>
<h3 id="stack-frames"><a class="header" href="#stack-frames">Stack frames</a></h3>
<p>The stack is used to implement functions for programs. For each function call,
a section of the stack is reserved for the function - a <strong>stack frame</strong>. Below
is some example C code that we will use for the rest of our stack frame
discussion:</p>
<pre><code class="language-c">int my_function(int a, int b) {
    char buffer[32];
    return a + b;
}

int main(int argc, char** argv) {
    my_function(1, 2);
    return 0;
}
</code></pre>
<p>Example assembly language output for the call to <code>my_function()</code> could be:</p>
<pre><code class="language-c">push    2               // push arguments in reverse
push    1
call    my_function     // push instruction pointer to stack and jump
                        // to beginning of my function
</code></pre>
<p>The above assembly code follows the <code>cdecl</code> calling convention, we'll also use
this calling convention for the rest of our discussion. The above assembly code
showcases how the arguments for the callee function, <code>my_function()</code>, are being
passed to the function by the caller, <code>main</code>, using the stack. The <code>call</code>
instruction <code>push</code>es the instruction pointer onto the stack. This will be used
by a <code>ret</code> instruction to return to the caller. <a href="common-vulnerabilities/stack-buffer-overflow.html#references">[3]</a></p>
<p>Entering <code>my_function()</code>, we'll see the <strong>function prologue</strong> setting up the
stack frame. Here's an example of what this would look like:</p>
<pre><code class="language-c">push    rbp         // save the frame pointer of the caller to the stack
mov     rbp, rsp    // set the new frame pointer
sub     rsp, 64     // make space for char buffer[32]
</code></pre>
<p>Below is an example of what the stack frame would look like for <code>my_function()</code>
:</p>
<pre><code class="language-c">0xdeadbeefcafe0000      buffer[0]               // rsp
...
0xdeadbeefcafe0040      buffer[31]              // end of buffer
0xdeadbeefcafe0048      saved frame pointer     // rbp
0xdeadbeefcafe0050      return address
0xdeadbeefcafe0058      a
0xdeadbeefcafe0060      b
</code></pre>
<p>Functions use the <code>rbp</code> and relative addressing to reference local variables
and parameters passed to the function.</p>
<p>Lastly, we have the <strong>function epilogue</strong> which reverses the actions of the
prologue, restoring the caller's stack frame and returning to the caller. An
example function prologue follows:</p>
<pre><code class="language-c">leave   // mov rsp, rbp; pop rbp;
ret
</code></pre>
<p>The <code>leave</code> instruction moves the <code>rsp</code> back to where it was before we entered
the function, directly after the caller executed the <code>call</code> instruction. The
<code>rbp</code> is also restored so the caller can correctly access the contents of its
stack frame when it resumes execution. The <code>ret</code> instruction sets the program
counter to the <strong>return address</strong> now contained at the top of the stack.
<a href="common-vulnerabilities/stack-buffer-overflow.html#references">[4]</a></p>
<h2 id="buffer-overflows"><a class="header" href="#buffer-overflows">Buffer overflows</a></h2>
<p>Finally, we can talk about stack buffer overflows and how they can be used to
hijack the execution of a process. Stack buffer overflow vulnerabilities are
a child of the out-of-bounds write weakness and are a condition in which a
buffer being overwritten is allocated on the stack.
<a href="common-vulnerabilities/stack-buffer-overflow.html#references">[5]</a><a href="common-vulnerabilities/stack-buffer-overflow.html#references">[6]</a>
Provided below is some example C code that contains a stack buffer overflow
vulnerability:</p>
<pre><code class="language-c">#define MAX_SIZE 64

int main(int argc, char** argv) {
    char buffer[MAX_SIZE] = {0};
    strcpy(buffer, argv[1]);

    return 0;
}
</code></pre>
<p>In this example, the size of <code>argv[1]</code> is not being checked prior to writing
its contents to the stack buffer, <code>char buffer[MAX_SIZE]</code>. If <code>argv[1]</code> is
greater than <code>MAX_SIZE</code>, the <code>strcpy()</code> operation will copy the contents of
<code>argv[1]</code> to <code>buffer</code> but will also overwrite the bytes directly after the
<code>buffer</code> variable on the stack.</p>
<p>Referencing the <strong>stack frame</strong> layout examples provided earlier, we can see
that this out-of-bounds write on the stack can lead to the corruption of
sensitive stack data, specifically the <strong>saved frame pointer</strong> and the <strong>return
address</strong>.</p>
<h3 id="so-how-can-this-lead-to-arbitrary-code-execution"><a class="header" href="#so-how-can-this-lead-to-arbitrary-code-execution">So how can this lead to arbitrary code execution?</a></h3>
<p>Stack information that is usually targeted by an attacker to gain code
execution is the return address. Overwriting this, an attacker can redirect
code execution to any location in memory in which the attacker has write
access. Historically, the first in-depth article that demonstrates using a
stack buffer overflow to gain arbitrary code execution is
<a href="common-vulnerabilities/stack-buffer-overflow.html#references">Smashing The Stack For Fun And Profit</a> by <strong>Aleph One</strong>.</p>
<p>As smashing the stack became more popular, various mitigations were implemented
to protect sensitive information on the stack from being overwritten, e.g.
stack canaries. Another mitigation involves setting permissions for segments of
memory within a process, and setting the permissions of the stack to be
read/write only - preventing the execution of shellcode stored in the stack.
These mitigations led to the creation of the <code>ret2*</code> techniques and return
oriented programming (ROP).</p>
<p>Other important stack information that can be targeted is the stack pointer and
the saved frame pointer. These values are used to conduct relative addressing
of variables within the stack frame, their corruption can be leveraged to
complete a &quot;write-what-where&quot; condition. Corruption of the stack pointer and
saved frame pointer can also be used to conduct a stack pivot, allowing the
attacker to control the location and contents of the stack frame used by the
calling function when it resumes execution.</p>
<h2 id="references-7"><a class="header" href="#references-7">References</a></h2>
<ol>
<li><a href="https://web.archive.org/web/20130225162302/http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/stack.html">https://web.archive.org/web/20130225162302/http://www.cs.umd.edu/class/sum2003/cmsc311/Notes/Mips/stack.html</a></li>
<li><a href="http://asm.sourceforge.net/articles/startup.html">http://asm.sourceforge.net/articles/startup.html</a></li>
<li><a href="https://www.agner.org/optimize/calling_conventions.pdf">https://www.agner.org/optimize/calling_conventions.pdf</a></li>
<li><a href="http://jdebp.eu./FGA/function-perilogues.html">http://jdebp.eu./FGA/function-perilogues.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/787.html">https://cwe.mitre.org/data/definitions/787.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/121.html">https://cwe.mitre.org/data/definitions/121.html</a></li>
<li><a href="http://phrack.org/issues/49/14.html">http://phrack.org/issues/49/14.html</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap-buffer-overflow"><a class="header" href="#heap-buffer-overflow">Heap buffer overflow</a></h1>
<h2 id="what-is-a-heap"><a class="header" href="#what-is-a-heap">What is a heap?</a></h2>
<p><strong>Heaps</strong> are contiguous blocks of memory chunks which <code>malloc()</code> allocates
to a process. Heaps are dynamic in nature, so memory can also be <code>free()</code>d
by a process when the memory is no longer needed. Heap memory is global and
can be accessed and modified from anywhere within the process when referenced
with a valid pointer. Heaps are treated differently depending on whether
they belong to the main arena or not - more on arenas later.</p>
<p><strong>Heaps</strong> can be created, extended, trimmed, and destroyed. The main arena
heap is created during the first request for dynamic memory while heaps for
other arenas are created with the <code>new_heap()</code> function. The main arena
heap grows and shrinks with the use of the <code>brk()</code> or <code>sbrk()</code> system calls.
These system calls are used to change the location of the program break,
defining the end of the process's <code>data</code> segment. Increasing the
program break allocates memory to the process; decreasing the break
deallocates memory. <a href="common-vulnerabilities/heap-buffer-overflow.html#references">[1]</a></p>
<h3 id="what-is-a-chunk"><a class="header" href="#what-is-a-chunk">What is a chunk?</a></h3>
<p>Chunks are the fundamental unit of memory that <code>malloc()</code> deals in, they are
pieces of heap memory. An allocated chunk in the heap is structured like this:</p>
<pre><code>            word/qword          |           word/qword

+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           prev size           |           chunk size        |A|M|P|
|   (not used while allocated)  |                                   |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           user data           |           user data               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           user data           |       size of next chunk    |A|M|P|
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</code></pre>
<p>The flags at the end of the second <code>word</code>/<code>qword</code> represent these chunk
properties:</p>
<ul>
<li><strong>A</strong> (<code>NON_MAIN_ARENA</code>) - <code>0</code> for chunks in the main arena. Each thread
spawned receives its own arena and for those chunks, this bit is set.</li>
<li><strong>M</strong> (<code>IS_MMAPPED</code>) - The chunk was obtained using <code>mmap()</code>.</li>
<li><strong>P</strong> (<code>PREV_INUSE</code>) - <code>0</code> when the previous chunk is free. The first chunk
allocated will always have this bit set. <a href="common-vulnerabilities/heap-buffer-overflow.html#references">[3]</a></li>
</ul>
<p>The minimum usable chunk size is <code>0x20</code>, and chunk sizes increase in
increments of 16 bytes: <code>0x20</code>, <code>0x30</code>, <code>0x40</code>, etc.</p>
<h4 id="the-top-chunk"><a class="header" href="#the-top-chunk">The top chunk</a></h4>
<p>The top chunk is the &quot;topmost available chunk, i.e. the one bordering the end
of available memory&quot;. Requests are only serviced from a top chunk when they
can't be serviced from any other bins in the same arena. <code>malloc()</code> keeps
track of the remaining memory in a top chunk using its <code>chunk_size</code> field,
and the <code>PREV_INUSE</code> bit of a top chunk is always set. A top chunk always
contains enough memory to allocate a minimum-sized chunk and always ends on a
page boundary. <a href="common-vulnerabilities/heap-buffer-overflow.html#references">[4]</a></p>
<h3 id="what-is-an-arena"><a class="header" href="#what-is-an-arena">What is an arena?</a></h3>
<p><code>malloc()</code> administrates a process's heaps using <code>malloc_state</code> structs, or
<strong>arenas</strong>. <strong>Arenas</strong> contain <strong>bins</strong>, data strucutures used for recycling
free chunks of heap memory. Definitions for each type of <strong>bin</strong> can be found
below:</p>
<h4 id="fastbins"><a class="header" href="#fastbins">fastbins</a></h4>
<ul>
<li>A collection of singly linked, non-circular lists that each hold free chunks
of a specific size.</li>
<li>The first <code>word</code>/<code>qword</code> of a chunk's user data is used as the forward
pointer (<code>fd</code>) when linked into a fastbin.</li>
<li>fastbins are LIFO data structures.</li>
<li>Free chunks are linked into the fastbin if the tcachebin is full.</li>
<li>For memory requests, the fastbin is searched after the tcachebin and before
any other bin.</li>
<li>There are 10 fastbins with chunk sizes: <code>16..88</code> bytes. <a href="common-vulnerabilities/heap-buffer-overflow.html#references">[2]</a></li>
</ul>
<h4 id="unsortedbin"><a class="header" href="#unsortedbin">unsortedbin</a></h4>
<ul>
<li>A doubly linked, circular list that holds free chunks of any size;
essentially used to optimize resource requests.</li>
<li>Free chunks are linked directly into the head of an unsortedbin when the
tcachebin is full or they are outside tcachebin size range.</li>
<li>The first <code>word</code>/<code>qword</code> of a chunk's user data is used as the forward
pointer (<code>fd</code>) and the second <code>word</code>/<code>qword</code> is used as a backwards pointer
(<code>bk</code>) when linked into an unsortedbin.
<ul>
<li>In versions of GLIBC compiled without the tcachebin, free chunks are linked
directly into the head of an unsortedbin when they are outside fastbin range.</li>
</ul>
</li>
<li>The unsortedbin is searched after the tcachebin, fastbin, and smallbins when
the request size fits those ranges, but before the largebins.</li>
<li>unsortedbin searches begin from the back and move towards the front.</li>
<li>If a request fits a chunk within the unsortedbin, the search is stopped and
the memory is allocated, otherwise the chunk is sorted into a smallbin or
largebin. <a href="common-vulnerabilities/heap-buffer-overflow.html#references">[2]</a></li>
</ul>
<h4 id="smallbins"><a class="header" href="#smallbins">smallbins</a></h4>
<ul>
<li>A collection of doubly linked, circular lists that each hold free chunks of a
specific size.</li>
<li>Free chunks are only linked into a smallbin when the chunk's arena sorts the
unsortedbin.</li>
<li>The first <code>word</code>/<code>qword</code> of a chunk's user data is used as the forward
pointer (<code>fd</code>) and the second <code>word</code>/<code>qword</code> is used as a backwards pointer
(<code>bk</code>) when linked into a smallbin.</li>
<li>smallbins are FIFO data structures.</li>
<li>For memory requests, smallbins are searched after the tcachebin, after
fastbins if the request was in fastbin size range, and before any other bins
are searched if the request was in smallbin range.</li>
<li>There are 62 smallbins with chunk sizes: <code>16..512</code> bytes (32-bit),
<code>16..1024</code> bytes (64-bit). <a href="common-vulnerabilities/heap-buffer-overflow.html#references">[2]</a></li>
</ul>
<h4 id="largebins"><a class="header" href="#largebins">largebins</a></h4>
<ul>
<li>A collection of doubly linked, circular lists that each hold free chunks
within a range of sizes.</li>
<li>Free chunks are only linked into a largebin when the chunk's arena sorts the
unsortedbin.</li>
<li>largebins are maintained in descending size order.
<ul>
<li>The largest chunk is accessible via the bin's <code>fd</code> pointer.</li>
<li>The smallest chunk is accessible via the bin's <code>bk</code> pointer.</li>
</ul>
</li>
<li>The first <code>word</code>/<code>qword</code> of a chunk's user data is used as the forward
pointer (<code>fd</code>) and the second <code>word</code>/<code>qword</code> is used as a backwards pointer
(<code>bk</code>) when linked into a largebin.</li>
<li>The first chunk of its size linked into a largebin has the third and fourth
<code>word</code>/<code>qword</code>s repurposed as <code>fd_nextsize</code> and <code>bk_nextsize</code>, respectively.</li>
<li>The nextsize pointers are used to form another doubly linked, circular list
holding the first chunk of each size linked into that largebin. Subsequent
chunks of the same size are added after the first chunk of that size.</li>
<li>The nextsize pointers are used as a skip list.</li>
<li>For memory requests, largebins are searched after an unsortedbin, but before
a binmap search.</li>
<li>There are 63 largebins with chunk sizes starting at: <code>512</code> bytes (32-bit),
<code>1024</code> bytes (64-bit). <a href="common-vulnerabilities/heap-buffer-overflow.html#references">[2]</a></li>
</ul>
<h4 id="what-is-a-tcache"><a class="header" href="#what-is-a-tcache">What is a tcache?</a></h4>
<p>A tcache behaves like an arena but, unlike arenas, is not shared between
threads of a process. They are created by allocating space on a heap belonging
to their thread's arena and are freed when the thread exits. The purpose of a
tcache is to relieve thread contention for malloc's resources by allocating to
each thread its own collection of chunks.</p>
<ul>
<li>The tcache is present in GLIBC versions &gt;= 2.26.</li>
<li>A tcache takes the form of a <code>tcache_perthread</code> struct which holds the heads
of 64 tcachebins preceded by an array of counters which record the number of
chunks in each tcachebin.</li>
<li>tcachebins are singly linked, non-circular lists of free chunks of a specific
size.</li>
<li>When a tcachebin reaches it's maximum number of chunks, free chunks of that
bin's size are instead treated as they would be without a tcache present.</li>
<li>There are 64 tcachebins with chunk sizes: <code>12..516</code> bytes (32-bit),
<code>24..1032</code> bytes (64-bit). <a href="common-vulnerabilities/heap-buffer-overflow.html#references">[2]</a></li>
</ul>
<h2 id="heap-overflow"><a class="header" href="#heap-overflow">Heap overflow</a></h2>
<p>OK, so all of the previous information was great right? It may seem like a lot,
but understanding the intricacies of the GLIBC Heap is important to effectively
exploit it. Now, I'll finally define what a heap overflow is:</p>
<p>&quot;A heap overflow is a buffer overflow, where the buffer that can be overwritten
is allocated in the heap portion of memory, generally meaning that the buffer
was allocated using a routine such as malloc().&quot; <a href="common-vulnerabilities/heap-buffer-overflow.html#references">[5]</a></p>
<p>Here's an example of code that presents a heap overflow vulnerability:</p>
<pre><code class="language-c">#define BUFSIZE 256
int main(int argc, char **argv) {
    char *buf;
    buf = (char *)malloc(sizeof(char)*BUFSIZE);
    strcpy(buf, argv[1]);
}
</code></pre>
<p>No bounds checking is conducted on <code>argv[1]</code> before its data is copied into
<code>buf</code>. <code>strcpy()</code> could possibly copy data from <code>argv[1]</code> well past the bounds
of the chunk that was allocated on the heap to hold <code>buf</code>.</p>
<p>Heap overflows are a dangerous weakness for a an application to have and, given
the right circumstances, attackers can utilize a variety of techniques to gain
arbitrary code execution. Techniques to exploit heap overflows have been
studied since the early 2000's and we'll cover a number of these techniques in
the following sections.</p>
<h2 id="references-8"><a class="header" href="#references-8">References</a></h2>
<ol>
<li><a href="https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf">https://www.blackhat.com/presentations/bh-usa-07/Ferguson/Whitepaper/bh-usa-07-ferguson-WP.pdf</a></li>
<li><a href="https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/">https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/</a></li>
<li><a href="https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk.html">https://heap-exploitation.dhavalkapil.com/diving_into_glibc_heap/malloc_chunk.html</a></li>
<li><a href="https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/">https://azeria-labs.com/heap-exploitation-part-1-understanding-the-glibc-heap-implementation/</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/122.html">https://cwe.mitre.org/data/definitions/122.html</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="house-of-force"><a class="header" href="#house-of-force">House of Force</a></h1>
<p>This is a pretty straight-foward and easy technique to understand. To utilize
the <strong>House of Force</strong> technique to gain code execution, an attacker needs the
following <a href="common-vulnerabilities/house-of-force.html#references">[1]</a>:</p>
<ul>
<li>Ability to conduct a heap overflow to overwrite the <code>top chunk</code> size field.</li>
<li>Conduct a <code>malloc()</code> call with an attacker-controlled size.</li>
<li>Conduct a final <code>malloc()</code> call where the attacker controls the user data.</li>
</ul>
<p>And the <strong>House of Force</strong> technique follows these steps:</p>
<ul>
<li>Attacker uses a heap buffer overflow to overwrite the <code>top chunk</code> size field,
usually something like <code>0xffffffffffffffff</code> == <code>-1</code>.
<ul>
<li>Because the <code>top chunk</code> size field is now <code>ULLONG_MAX</code>, calls to <code>malloc()</code>
can be arbitrarily large and the <code>top chunk</code> will be offset by the size of the
call, allowing the attacker to place the <code>top chunk</code> pointer anywhere in memory
.</li>
</ul>
</li>
<li>Attacker requests a chunk of size <code>x</code>, placing the <code>top chunk</code> directly
before the target that the attacker intends to write to.</li>
<li>Attacker uses a final allocation to create a chunk with its user data
overlapping the target.</li>
</ul>
<h2 id="what-are-some-good-targets-to-overwrite"><a class="header" href="#what-are-some-good-targets-to-overwrite">What are some good targets to overwrite?</a></h2>
<p>Typically, attackers will attempt to write to these <code>glibc</code> symbols:</p>
<ul>
<li><code>__malloc_hook</code></li>
<li><code>__free_hook</code></li>
</ul>
<p>The <code>__malloc_hook</code> and <code>__free_hook</code> symbols are used by <code>glibc</code> to allow
programmers the ability to register functions that will be executed when calls
to <code>malloc()</code> or <code>free()</code> are made. These can be used by a programmer to
acquire statistics, install their own versions of these functions, etc.</p>
<p>Attackers use these hooks to redirect program execution to memory that they
control within the program. For instance, an attacker could write the address
of their ROP chain into either hook, force the program to call <code>malloc()</code> or
<code>free()</code>, and then begin executing their ROP chain to conduct a stack pivot,
etc. It's also possible to overwrite either hook to point to a <code>one_gadget</code> or
<code>system()</code> - you get the picture.</p>
<p>Some other less common targets are:</p>
<ul>
<li>The <code>got.plt</code> section of the program</li>
<li>The process stack</li>
</ul>
<p>Going after the Global Offset Table (GOT) to obtain arbitrary code execution is
only a viable option if full Relocation Read-Only (<code>RELRO</code>) <a href="common-vulnerabilities/house-of-force.html#references">[2]</a>
is not enabled. Otherwise, the attacker would encounter a <code>SIGSEV</code> by trying to
write to memory that is not marked as writeable.</p>
<p>Going after the process stack is also a possibility - the attacker could try to
overwrite the <code>return address</code> of a stack frame if they know where it resides
in memory. Unfortunately, Address Space Layout Randomization (<code>ASLR</code>) makes this
difficult to achieve.</p>
<h2 id="patch"><a class="header" href="#patch">Patch</a></h2>
<p>The <strong>House of Force</strong> went unpatched for 13 years, but an update was finally
made to <code>glibc</code> to check the size of the top chunk on 16 AUG 2018.
<a href="common-vulnerabilities/house-of-force.html#references">[3]</a> The <strong>House of Force</strong> still works for <code>glibc</code> versions
less than <code>2.29</code>.</p>
<h2 id="references-9"><a class="header" href="#references-9">References</a></h2>
<ol>
<li><a href="https://gbmaster.wordpress.com/2015/06/28/x86-exploitation-101-house-of-force-jedi-overflow/">https://gbmaster.wordpress.com/2015/06/28/x86-exploitation-101-house-of-force-jedi-overflow/</a></li>
<li><a href="https://ctf101.org/binary-exploitation/relocation-read-only/">https://ctf101.org/binary-exploitation/relocation-read-only/</a></li>
<li><a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c">https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=30a17d8c95fbfb15c52d1115803b63aaa73a285c</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="house-of-orange"><a class="header" href="#house-of-orange">House of Orange</a></h1>
<p>The original <strong>House of Orange</strong> technique used a heap overflow vulnerability
to target the <code>top chunk</code> in its first stage of exploitation. Due to this fact,
we can determine that the <strong>House of Orange</strong> fits within this section of heap
exploitation.</p>
<h2 id="the-technique"><a class="header" href="#the-technique">The technique</a></h2>
<p>The <strong>House of Orange</strong> is an interesting, but somewhat convoluted, technique
to gain arbitrary code execution of a vulnerable process. The
<strong>House of Orange</strong> is executed in three stages:</p>
<ul>
<li>
<p>Leverage a heap overflow vulnerability to overwrite the size field of the
<code>top chunk</code>.</p>
<ul>
<li>Overwrite the <code>top chunk</code> with a small size, fooling <code>malloc()</code> in future
requests to believe that the <code>top chunk</code> is smaller than it actually is.</li>
<li>The new <code>top chunk</code> size must be page-aligned and the <code>prev_inuse</code> bit must
be set in order to pass <code>malloc()</code> checks.</li>
<li>The attacker forces the program to make another <code>malloc()</code> call with a size
larger than what is currently written to the <code>top chunk</code> size field.</li>
<li>This <code>malloc()</code> call will cause <code>malloc()</code> to <code>mmap()</code> a new segment of
heap memory. <code>malloc()</code> will also determine that the new segment of heap memory
and the <code>top chunk</code> are not contiguous, causing <code>malloc()</code> to <code>free()</code> the
remaining space of the <code>top chunk</code>.</li>
<li>This newly free chunk will be too large for the fastbin, it will be linked
into the unsortedbin.</li>
</ul>
</li>
<li>
<p>Use the same heap overflow vulnerability and chunk to overwrite the newly
freed <code>top chunk</code> that resides in the unsortedbin.</p>
<ul>
<li>The attacker forges the metadata for a fake chunk, setting the chunk size
to <code>0x61</code>, and setting the <code>bk</code> pointer to a chunk that overlaps <code>_IO_list_all</code>
in <code>glibc</code>
.</li>
<li>The attacker will use this to conduct an <strong>Unsortedbin Attack</strong>, writing
the memory address of the unsortedbin head in the <code>main arena</code> to
<code>_IO_list_all</code>.</li>
<li>The attacker uses the heap overflow to write a fake <code>_IO_FILE</code> struct into
the heap, forging a <code>vtable_ptr</code> that points back into attacker controlled
memory with the intent of overwriting the <code>overflow</code> method of the struct to
<code>system()</code>.</li>
</ul>
</li>
<li>
<p>The attacker requests a chunk smaller than the forged chunk that was just
created, causing <code>malloc()</code> to sort the free chunk into the smallbin,
triggering an <strong>Unsortedbin Attack</strong>.</p>
<ul>
<li><code>malloc()</code> attempts to follow our forged <code>bk</code>, however, chunk metadata
checks will cause <code>malloc()</code> to call <code>__malloc_printerr()</code>, leading to a
<code>SIGABRT</code>.</li>
<li>When the program begins its exit procedures, it attempts to clear the
buffers of all open file streams, including our forged one.</li>
<li><code>glibc</code> follows <code>_IO_list_all</code> which now points to the <code>main_arena</code>. The
<code>main_arena</code> fails <code>_IO_FILE</code> struct checks, and <code>glibc</code> moves on to the next
<code>_IO_FILE</code> struct pointed to by the <code>main_arena</code>'s fake <code>chain</code> member - our
smallbin.</li>
<li><code>glibc</code> inspects the forged <code>_IO_FILE</code> struct the attacker created in the
heap using a heap overflow and executes the <code>overflow</code> method listed in the
<code>vtable</code> of the forged <code>_IO_FILE</code> struct. The attacker has overwritten the
<code>overflow</code> method listed in the <code>vtable</code> to point to <code>system()</code>.</li>
<li>The address of the <code>_IO_FILE</code> is passed to this call to <code>system()</code> - the
attacker ensures that the string <code>/bin/sh\0</code> resides at this location, the
very first word of bytes in the forged <code>_IO_FILE</code> struct.</li>
</ul>
</li>
</ul>
<h3 id="some-notes"><a class="header" href="#some-notes">Some notes</a></h3>
<p>Like I said, this technique is convoluted. The attacker needs to have the
following in order to exploit this vulnerability:</p>
<ul>
<li>Ability to edit chunk data</li>
<li>Ability to control <code>malloc()</code> allocation size</li>
<li>Heap and <code>glibc</code> address leak if <code>ASLR</code> is enabled</li>
<li>Heap overflow</li>
</ul>
<h2 id="patch-1"><a class="header" href="#patch-1">Patch</a></h2>
<p>There doesn't seem to be any specific patch that attempts to mitigate
exploitation using the <strong>House of Orange</strong>. Because there are so many
conditions necessary to effectively exploit this technique, the summation of
the mitigations applied to <code>glibc</code> over the years have made this technique
obsolete.</p>
<p>For instance, the patch applied to actually check the validity of the <code>bk</code>
pointer in the unsortedbin causes the <strong>Unsortedbin Attack</strong> used to execute
this technique to fail. In addition, <code>glibc</code> after version <code>2.28</code> no longer
traverses through all open file streams at program exit to call the <code>overflow</code>
method of the stream. This mitigation thwarts this techniques use of
<strong>File Stream Oriented Programming</strong> to gain code execution.</p>
<h2 id="references-10"><a class="header" href="#references-10">References</a></h2>
<ol>
<li><a href="https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html">https://4ngelboy.blogspot.com/2016/10/hitcon-ctf-qual-2016-house-of-orange.html</a></li>
<li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/fsop/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/fsop/</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-byte-overflows"><a class="header" href="#single-byte-overflows">Single Byte Overflows</a></h1>
<p>Single byte overflows are pretty dangerous bugs to have in a program, given the
right conditions. A stack-based, single byte, <code>NULL</code> buffer overflow was
demonstrated in this <a href="https://seclists.org/bugtraq/1998/Oct/109">this post</a> in
1998, used to overwrite the LSB of the <code>ebp</code> causing the stack frame to be
relocated to a lower address in memory - a location in the stack that the user
controls and can forge a fake stack frame.</p>
<p>In 2014, Google Project Zero releases <em>The poisoned NUL byte, 2014 edition</em>,
demonstrating that a heap-based, single byte, <code>NULL</code> buffer overflow can also
be used to gain code execution. <a href="common-vulnerabilities/single-byte-overflows.html#references">[2]</a></p>
<h2 id="techniques"><a class="header" href="#techniques">Techniques</a></h2>
<p>The following subsections cover a white paper from Accenture Security that goes
in-depth on different methods of exploiting a one byte heap-based buffer
overflow to gain overlapping chunks and possibly code execution.
<a href="common-vulnerabilities/single-byte-overflows.html#references">[3]</a></p>
<h3 id="extending-free-chunks"><a class="header" href="#extending-free-chunks">Extending free chunks</a></h3>
<p>A diagram for this technique can be found in section 3.2.1 of
<a href="common-vulnerabilities/single-byte-overflows.html#references">[3]</a>. With a one byte heap-based buffer overflow, the attacker
will write actual information to the <code>size</code> field of a free chunk, increasing
its size. An allocation larger than the corrupted chunk's original size will
cause the chunk to overlap into succeeding chunks.</p>
<p>This scenario relies on the fact that <code>malloc()</code> does not check the <code>prev_size</code>
field of the succeeding chunk when allocating a previously <code>free()</code>d chunk.</p>
<h3 id="extending-allocated-chunks"><a class="header" href="#extending-allocated-chunks">Extending allocated chunks</a></h3>
<p>This technique is similar to the one above, it's just that the series of
operations is reordered. A diagram for this technique can be found in section
3.2.2 of <a href="common-vulnerabilities/single-byte-overflows.html#references">[3]</a>. Essentially, the corruption happens before the
victim, corrupted chunk is <code>free()</code>d. An attacker writes one byte, increasing
the size of the corrupted chunk. After the corrupted chunk is <code>free()</code>d,
another allocation is requested with a size greater than the original size
of the corrupted chunk, causing the corrupted chunk's user data to overlap
the succeeding chunk.</p>
<p>This technique exploits the fact that <code>free()</code> has no ability to determine if
the corrupted chunk's <code>size</code> field is supposed to be larger or smaller, as the
only location that contains the chunk's size metadata is the <code>size</code> field
corrupted by the one byte heap-based buffer overflow.</p>
<h3 id="shrinking-free-chunks"><a class="header" href="#shrinking-free-chunks">Shrinking free chunks</a></h3>
<p>Here's our heap-based, single byte, <code>NULL</code> buffer overflow - a memory
corruption vulnerability that can lead to some interesting outcomes. A good
demonstration of this technique exists on the <code>how2heap</code> repo,
<a href="common-vulnerabilities/single-byte-overflows.html#references">here</a>. The diagram for this technique can be found in section
3.2.3 of <a href="common-vulnerabilities/single-byte-overflows.html#references">[3]</a>.</p>
<p>The initial state of the program involves having three chunks allocated on the
heap, all too large for the fastbin. The chunk in the middle of these three
will have a size such that a <code>NULL</code> byte buffer overflow from the preceding
chunk will overwrite the <code>size</code> field of the middle chunk, causing it to shrink
in size. The example provided sets the middle chunk's size to <code>0x210</code> and,
after the <code>NULL</code> byte overflow, its size is set to <code>0x200</code>.</p>
<p>Before the memory corruption occurs, the middle chunk is <code>free()</code>d. This is
required because the <code>prev_size</code> field of the succeeding chunk must be set to
<code>0x210</code>. The attacker conducts the <code>NULL</code> byte buffer overflow and sets the
free chunk's size to <code>0x200</code>. <strong>In later updates to <code>glibc</code>, the <code>prev_size</code>
field and the <code>size</code> field of the chunk about to be backwards consolidated is
now checked for consistency. Attackers must now write a valid <code>prev_size</code> field
to the succeeding chunk before attempting this backwards consolidation.</strong></p>
<p>Two chunk are now allocated from this newly <code>free()</code>d space, one chunk that's
not within fastbin range, and subsequent chunks that are. We want chunks that
are in fastbin range to avoid having these chunks subjected to <code>malloc()</code>'s
consolidation and sorting behavior. We free the first chunk of the two chunks
we just allocted, placing it in the unsortedbin.</p>
<p>Almost there, the attacker frees the third chunk of the original three, causing
<code>free()</code> to inspect the <code>prev_size</code> field of the third chunk and consolidating
it with the chunk that we just <code>free()</code>d into the unsortedbin. This free space
now overlaps the fastbin sized chunk we allocated earlier.</p>
<p>Finally, we allocate a chunk large enough to overlap the fastbin sized chunk
that still remains. Because of this heap-based, one byte, <code>NULL</code> buffer
overflow, we have allocated two chunks that overlap one another which can
easily lead to the implementation of other exploitation primitives.</p>
<h3 id="exploitation"><a class="header" href="#exploitation">Exploitation</a></h3>
<p>In <a href="common-vulnerabilities/single-byte-overflows.html#references">[3]</a>, further dicussion is provided on how to use overlapping
chunks to leak sensitive information and gain code exeuction. In section 4.3.2,
the authors demonstrate that they can create overlapping unsortedbin size
chunks.</p>
<p>They <code>free()</code> the unsortedbin eligible chunk, and the pointer to the head of
the unsortedbin, which resides in the <code>main_arena</code>, is written to the <code>fd</code> and
<code>bk</code> pointers of the chunk. Because they still maintain a chunk overlapping
this now free chunk, they can leak the memory of the free chunk to obtain its
<code>fd</code> and <code>bk</code> pointers, providing them a <code>glibc</code> leak.</p>
<p>Not covered in this white paper, but possible nonetheless, is that the
allocation and <code>free()</code>ing of two fastbin eligible chunks can lead to a heap
location leak. If these two fastbin eligible chunks are <code>free()</code>d while being
overlapped by a much larger, allocated chunk, the attacker could feasibly read
the <code>fd</code> pointers of these fastbin free chunks to derive the base of the heap.</p>
<p>Finally, to gain code execution, the authors of this white paper use a Global
Offset Table (GOT) overwrite. For the application they are exploiting, the
program maintains sensitive structures within the heap and, within these
structures, there are pointers that will be used to write incoming data from
a socket connection. The authors generate two of these structures in the heap,
one to leak <code>glibc</code> and one to conduct arbitrary writes. The authors use the
<code>glibc</code> leak to derive the location of the GOT - for this application's
environment, the GOT is always a fixed offset away from the <code>glibc</code> base. Once
they've derived the location of <code>free@GOT</code>, they corrupt a heap structure's
write pointer to point to <code>free@GOT</code>. After this, they send a message which
causes the program to overwrite <code>free@GOT</code> with the pointer to <code>system@libc</code>.
Coercing the program to call <code>free@plt</code> leads to <code>system@libc</code> with a command
they provide.</p>
<h2 id="patch-2"><a class="header" href="#patch-2">Patch</a></h2>
<p>A patch that thwarts the shrinking of chunks to gain overlapping chunks was
implemented on AUG 2018. This is referenced by the note earlier, as this patch
conducts a consistency check between the <code>next-&gt;prev_size</code> and <code>victim-&gt;size</code>
of a <code>victim</code> within the unsortedbin before sorting or consolidating the
<code>victim</code>. <a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c">[5]</a></p>
<h2 id="references-11"><a class="header" href="#references-11">References</a></h2>
<ol>
<li><a href="https://seclists.org/bugtraq/1998/Oct/109">https://seclists.org/bugtraq/1998/Oct/109</a></li>
<li><a href="https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html">https://googleprojectzero.blogspot.com/2014/08/the-poisoned-nul-byte-2014-edition.html</a></li>
<li><a href="https://www.contextis.com/en/resources/white-papers/glibc-adventures-the-forgotten-chunks">https://www.contextis.com/en/resources/white-papers/glibc-adventures-the-forgotten-chunks</a></li>
<li><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.23/poison_null_byte.c">https://github.com/shellphish/how2heap/blob/master/glibc_2.23/poison_null_byte.c</a></li>
<li><a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c">https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-after-free-uaf"><a class="header" href="#use-after-free-uaf">Use-after-free (UAF)</a></h1>
<p>The <strong>Use-after-free</strong> vulnerability can be defined as the use of heap
allocated memory after it has been freed or deleted. <a href="common-vulnerabilities/use-after-free.html#references">[1]</a> This
can lead to undefined behavior by the program and is commonly used by attackers
to implement a <strong>Write-what-where</strong> condition. <a href="common-vulnerabilities/use-after-free.html#references">[2]</a></p>
<p><strong>Double frees</strong> and UAF vulnerabilities are closely related, and double frees
can be used to duplicate chunks in the fastbin, eventually allowing the
attacker to acquire a pointer to free memory. <a href="common-vulnerabilities/use-after-free.html#references">[3]</a>
<strong>Heap overflows</strong> can also lead to a UAF vulnerability, given the right
conditions. This is discussed further in the exploitation portion of
<a href="common-vulnerabilities/./single-byte-overflows.html">Single Byte Overflows</a> as we leak <code>glibc</code>
addresses from an unsortedbin chunk using our overlapping chunk.</p>
<p>Provided below is an example of a UAF from OWASP.org <a href="common-vulnerabilities/use-after-free.html#references">[4]</a>:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

#define BUFSIZER1   512
#define BUFSIZER2   ((BUFSIZER1/2) - 8)

int main(int argc, char **argv) {
	char *buf1R1;
	char *buf2R1;
	char *buf2R2;
	char *buf3R2;

	buf1R1 = (char *) malloc(BUFSIZER1);
	buf2R1 = (char *) malloc(BUFSIZER1);

	free(buf2R1);

	buf2R2 = (char *) malloc(BUFSIZER2);
	buf3R2 = (char *) malloc(BUFSIZER2);

	strncpy(buf2R1, argv[1], BUFSIZER1-1);
	free(buf1R1);
	free(buf2R2);
	free(buf3R2);
}
</code></pre>
<p>The following sections, <a href="common-vulnerabilities/./fastbin-dup.html">Fastbin Dup</a> and
<a href="common-vulnerabilities/./unsortedbin-attack.html">Unsortedbin Attack</a>, demonstrate how UAF
vulnerabilities can be leveraged to gain arbitrary code execution.</p>
<h2 id="references-12"><a class="header" href="#references-12">References</a></h2>
<ol>
<li><a href="https://cwe.mitre.org/data/definitions/416.html">https://cwe.mitre.org/data/definitions/416.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/123.html">https://cwe.mitre.org/data/definitions/123.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/415.html">https://cwe.mitre.org/data/definitions/415.html</a></li>
<li><a href="https://owasp.org/www-community/vulnerabilities/Using_freed_memory">https://owasp.org/www-community/vulnerabilities/Using_freed_memory</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fastbin-dup"><a class="header" href="#fastbin-dup">Fastbin Dup</a></h1>
<p>While the Fastbin Dup technique can be implemented using a heap buffer overflow
, the most common example used to demonstrate this technique is by using the
Use-after-free (UAF) and Double Free vulnerabilities.</p>
<h2 id="the-technique-1"><a class="header" href="#the-technique-1">The technique</a></h2>
<p>The steps to execute the Fastbin Dup technique are as follows:</p>
<ul>
<li>Leverage a Double Free vulnerability to free a victim chunk twice - this
chunk must be small enough that it gets linked into the fastbin.</li>
<li>Coerce the program to execute <code>malloc()</code> to allocate the victim chunk from
the fastbin.</li>
<li>Overwrite the <code>fd</code> pointer of the victim chunk to point to a fake chunk that
overlaps the location of our arbitrary write target.
<ul>
<li><strong>Since the inception of this technique, there have been some <code>glibc</code>
mitigations implemented to check if the next chunk in the fastbin contains a
valid size field. You can find fake chunk candidates near your target write
location using the <code>find_fake_fast</code> command with <code>pwndbg</code>.</strong></li>
</ul>
</li>
<li>Coerce the program to execute <code>malloc()</code> until we receive a pointer to the
same victim chunk, however, this time we don't need to do anything with the
user data. The chunk overlapping our write target now exists within the
fastbin.</li>
<li>Coerce the program to execute <code>malloc()</code> one last time, providing us a
pointer to the chunk overlapping our write target.</li>
<li>Use the pointer to the fake chunk to conduct our arbitrary write.</li>
</ul>
<h3 id="write-targets"><a class="header" href="#write-targets">Write targets</a></h3>
<p>So what targets do we wish to write to? Well, the usual candidates are: the
<code>__free_hook</code>, <code>__malloc_hook</code>, or the Global Offset Table (GOT). Other
techniques also target the stack which is a viable option if you can accurately
determine where the return address of the current function is located. After we
gain the ability to conduct an arbitrary write, gaining code execution should
be trivial with any other technique.</p>
<h3 id="requirements"><a class="header" href="#requirements">Requirements</a></h3>
<p>An attacker using the Fastbin Dup must have these conditions present:</p>
<ul>
<li>Have chunks that are in the fastbin</li>
<li>Have a UAF vulnerability with the ability to control the data written to the
free chunk</li>
<li>Have the ability to control the data written to the chunk that overlaps the
write target (<code>__free_hook</code>, etc.)</li>
<li>Have a memory leak that allows the attacker to defeat ASLR if enabled</li>
</ul>
<h2 id="patch-3"><a class="header" href="#patch-3">Patch</a></h2>
<p>Unfortunately, the researchers at <strong>Checkpoint Research</strong> proposed protections
for the <code>fd</code> pointers used to implement the linked list data structures of the
fastbin and tcache. <a href="common-vulnerabilities/fastbin-dup.html#references">[2]</a> To prevent attackers from leveraging the
Fastbin and Tcache Dup techniques, these researchers implemented the
<code>PROTECT_PTR</code> and <code>REVEAL_PTR</code> macros for the <code>fd</code> pointer of the fastbin and
tcache singly-linked lists.</p>
<p>Summarizing the implementation of these macros, the <code>fd</code> pointer of the fastbin
and tcache are mangled using the random bits of the virtual memory address
currently holding the <code>fd</code> pointer. The macro definitions are as follows
<a href="common-vulnerabilities/fastbin-dup.html#references">[3]</a>:</p>
<pre><code class="language-c">#define PROTECT_PTR(pos, ptr) \
  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))
#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)
</code></pre>
<p>These mitigations make the Fastbin Dup technique significantly harder to pull
off. Now, in order to forge a <code>fd</code> pointer, the attacker has to leak
sensitive information from the process to derive the location of their
arbitrary write target in memory. They must use that same address to mangle
their forged <code>fd</code> pointer before writing it to the victim chunk. The final
nail in the coffin, however, is the fact that the pointer must be page-aligned.
This, coupled with checks done by <code>glibc</code> to verify the size field of our fake
chunk overlapping our write target, invalidates our ability to use the above
technique to overwrite something like the <code>__malloc_hook</code> to gain control of
the <code>RIP</code>.</p>
<h2 id="references-13"><a class="header" href="#references-13">References</a></h2>
<ol>
<li><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_dup.c">https://github.com/shellphish/how2heap/blob/master/glibc_2.31/fastbin_dup.c</a></li>
<li><a href="https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/">https://research.checkpoint.com/2020/safe-linking-eliminating-a-20-year-old-malloc-exploit-primitive/</a></li>
<li><a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41">https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=a1a486d70ebcc47a686ff5846875eacad0940e41</a> </li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsortedbin-attack"><a class="header" href="#unsortedbin-attack"><strong>Unsortedbin Attack</strong></a></h1>
<p>The <strong>Unsortedbin Attack</strong> and the Use-after-free (UAF) vulnerability are loosely
related enough for me to write about it in this section. The <strong>Unsortedbin Attack</strong>
can be used if you have a heap overflow vulnerability, as shown in the House of
Orange, however, for that version of the technique to work some special
conditions need to be present. For the purpose of this discussion, we're only
going to concern ourselves with the <strong>Unsortedbin Attack</strong> implemented with a
Use-after-free (UAF) vulnerability.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it works</a></h2>
<p>This technique is actually pretty simple. To leverage this attack, the attacker
needs to be able to:</p>
<ul>
<li>Acquire a chunk on the heap that is too large for the fastbin</li>
<li>Acquire another chunk after the previously mentioned chunk that acts as a
fencepost between the previously mentioned chunk and the top chunk.</li>
<li>Free the first chunk.</li>
<li>Edit the first chunk (UAF vulnerability).</li>
<li>Execute another <code>malloc()</code>, requesting a chunk of the same size as the one
that was <code>free()</code>'d and linked into the Unsortedbin.</li>
</ul>
<h3 id="so-what-happens-here"><a class="header" href="#so-what-happens-here">So what happens here?</a></h3>
<p>The first chunk on the heap is too large for the fastbin so, when it is
<code>free()</code>'d, it is linked into the Unsortedbin. This free chunk will be linked
into a small or largebin, based upon its size, during the next call to
<code>malloc()</code>. We create a buffer chunk between this previously mentioned chunk
and the top chunk prior to trying to <code>free</code> the first chunk, otherwise our
victim chunk will be consolidated into the top chunk.</p>
<p>With our Use-after-free (UAF) vulnerability, we overwrite the <code>bk</code> pointer of
the chunk in the Unsortedbin to point to an address that we want to write to.
What are we writing? Well, when an Unsortedbin chunk is chosen to service a
<code>malloc()</code> call, the memory address of the <code>main_arena</code> that contains the head
of the Unsortedbin is written to where the <code>bk</code> points to.</p>
<h2 id="how-is-this-used-for-exploitation"><a class="header" href="#how-is-this-used-for-exploitation">How is this used for exploitation?</a></h2>
<p>Honestly, the <strong>Unsortedbin Attack</strong> is often used to enable other techniques. It's
usually a precursor to further exploitation but, by itself, it's not useful for
gaining code execution.</p>
<p>A great example technique that leverage the <strong>Unsortedbin Attack</strong> to gain code
execution is the <a href="common-vulnerabilities/./house-of-orange.html">House of Orange</a>. In that example,
however, the vulnerability leveraged to overwrite the <code>bk</code> of the chunk in the
Unsortedbin is a heap overflow.</p>
<p>Another good example is the <a href="common-vulnerabilities/unsortedbin-attack.html#references">zerostorage</a> challenge from 0ctf 2016
. In this challenge, the attacker uses a UAF vulnerability to overwrite the
<code>bk</code> of a chunk in the Unsortedbin and then forces an allocation of this chunk
to overwrite the symbol <code>libc.global_max_fast</code>. <code>global_max_fast</code> represents
the largest size a fastbin chunk can be - overwriting it with the memory
address that contains the Unsortedbin head, making the size of fastbin chunks
almost arbitrarily large.</p>
<p>Using the above, the attacker now has the ability to create fastbin chunks and,
because a UAF vulnerability is present, the attacker can leverage the Fastbin
Dup to gain code execution, targeting the <code>__free_hook</code>.</p>
<h2 id="patch-4"><a class="header" href="#patch-4">Patch</a></h2>
<p>The <strong>Unsortedbin Attack</strong> went unpatched until <code>glibc 2.29</code>, commited to the
<code>glibc</code> repo on 17 AUG 2018. Before the patch, no integrity checks were
conducted on the fake chunk pointed to by the corrupted <code>bk</code> pointer used in
this technique. Now, integrity checks are conducted on the free chunk being
inspected in the Unsortedbin, the <code>next</code> chunk of the victim free chunk, and
the chunk pointed to by <code>bk</code>. <a href="common-vulnerabilities/unsortedbin-attack.html#references">[2]</a>.</p>
<h2 id="references-14"><a class="header" href="#references-14">References</a></h2>
<ol>
<li><a href="https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html">https://guyinatuxedo.github.io/31-unsortedbin_attack/0ctf16_zerostorage/index.html</a></li>
<li><a href="https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c">https://sourceware.org/git/?p=glibc.git;a=commitdiff;h=b90ddd08f6dd688e651df9ee89ca3a69ff88cd0c</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="heap-grooming"><a class="header" href="#heap-grooming">Heap grooming</a></h1>
<p>Let's first define <strong>heap grooming</strong> by identifying that it's not
<strong>heap spraying</strong>. While these two concepts are related, heap spraying is used
to make other exploitation techniques more reliable. Heap spraying gained
popularity starting in 2001, and is primarily used to store code in a reliable
location when attempting to gain code execution. <a href="common-vulnerabilities/heap-grooming.html#references">[1]</a></p>
<p><strong>Heap grooming</strong> or <strong>heap feng shui</strong> or <strong>heap shaping</strong> is a more nuanced
technique that attempts to shape the heap in a manner that allows for follow
on exploitation by the attacker. The use of this technique is pivotal to
improving the reliability of using heap memory corruption for exploitation. For
example, in order to use a heap overflow to create the conditions for
overlapping chunks or a Use-after-free (UAF) vulnerability, the attacker might
want to have chunks of specific sizes in specific locations or have program
data structures in advantageous locations for sensitive information leaks, etc.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<h3 id="heap-feng-shui-in-javascript"><a class="header" href="#heap-feng-shui-in-javascript">Heap Feng Shui in Javascript</a></h3>
<p>First, we'll start with <a href="common-vulnerabilities/heap-grooming.html#references">this BlackHat</a> talk by Alexander Sotirov.
It's actually pretty awesome that something this intense was discussed as early
as 2007. Alexander's talk begins with a description of heap spraying, but shows
that, while heap spraying is useful, it's still unreliable - we need the heap
to be in a deterministic state to achieve reliable exploitation.</p>
<p>His <strong>Heap Feng Shui</strong> portion of the talk discusses how the heap allocator is
deterministic in nature. The attacker must coerce the program to execute a
series of allocations and frees until he deterministically controls important
locations in the heap. Eventually, he demonstrates that the attacker can place
malicious bytes onto the heap in a repeated nature, coerce the program to free
his allocated chunks, and then, when the program resumes a different
subroutine and allocates the recently <code>free()</code>d chunks, the attacker can
exploit an unitialized variable vulnerability to gain code execution.</p>
<p>He goes on to discuss how the memory allocator works for Javascript / Internet
Explorer and his creation of a library that allows him to log, debug, allocate,
and free heap chunks of arbitrary size and contents within the Javascript /
Internet Explorer heap.</p>
<h3 id="grooming-the-ios-kernel-heap"><a class="header" href="#grooming-the-ios-kernel-heap">Grooming the iOS Kernel Heap</a></h3>
<p>Next, we'll talk about
<a href="common-vulnerabilities/heap-grooming.html#references">Azeria's discussion on grooming the iOS kernel heap</a>. In this
real world example, she demonstrates the exploitation of a one byte, heap
overflow vulnerability to gain a UAF that allows her to leak sensitive
information from program memory.</p>
<p>In this example, Azeria discusses that the state of the heap before
exploitation is fragmented, with free and allocated chunks sparsely strewn
about the heap. She coerces the application to fill the &quot;gaps&quot; in the heap by
allocating objects until the freelist is empty. Subsequent allocations will
then start at the highest address of the heap where she begins to create a
series of &quot;exploit zones&quot;, comprised of victim objects and placeholder objects.
The victim objects will be used to overflow into succeeding objects on the
heap. She <code>free()</code>s all of the placeholder objects in quick succession, linking
them into the freelist. When the kernel allocates her target objects that she
wishes to overflow into, the new allocations will be adjacent to the victim
objects.</p>
<p>Using <strong>heap grooming</strong>, Azeria demonstrates that an attacker can coerce the
allocator into placing victim objects next to sensitive kernel objects on the
heap in order to corrupt heap memory, leading to a sensitive information
disclosure.</p>
<h3 id="chrome-os-exploit-one-byte-overflow-and-symlinks"><a class="header" href="#chrome-os-exploit-one-byte-overflow-and-symlinks">Chrome OS exploit: one byte overflow and symlinks</a></h3>
<p><code>shill</code>, the Chrome OS network manager, had a one byte heap overflow in its
DNS library. Attackers could communicate with the library using an HTTP proxy
that was listening on <code>localhost</code>. The author demonstrates his use of
<strong>heap grooming</strong> to ensure that the memory layout of the vulnerable process
remained predictable so that he could reliably place allocations in the same
location in heap memory.</p>
<p>The author demonstrates that, upon each connection, four allocations are
conducted by the program to hold program data on the heap. When the connection
closes, however, the middle <code>0x820</code> bytes in these four allocations are
<code>free()</code>d and consolidated, and the two still allocated chunks protect the
free <code>0x820</code> chunk from being further consolidated or modified.</p>
<p>The author goes on to explain that, in order to continue to reliably use this
<code>0x820</code> chunk of memory to obtain overlapping chunks, he has to coerce the
program to conduct &quot;tons of small allocations&quot; in order to empty the freelist.
Finally, subsequent allocations allow him to reliably use his <code>0x820</code> chunk of
memory, eventually conducting a heap buffer overflow to shrink a free chunk
causing a future <code>free()</code> operation on a succeeding chunk to overlap an
allocated chunk. <a href="common-vulnerabilities/heap-grooming.html#references">[4]</a></p>
<h2 id="malloc-tunables"><a class="header" href="#malloc-tunables">Malloc tunables</a></h2>
<p>A listing of <code>malloc</code> tunables can be found <a href="common-vulnerabilities/heap-grooming.html#references">here</a>. There's not
much documentation on how <code>malloc</code> tunables can affect exploitation methods,
or my Google-Fu is probably just not good enough. Either way, in this section
I'll wargame some <code>malloc</code> tunable changes that could possibly bring about
interesting changes to how we approach heap exploitation.</p>
<h3 id="glibcmalloctcache_count-and-glibcmalloctache_max"><a class="header" href="#glibcmalloctcache_count-and-glibcmalloctache_max"><code>glibc.malloc.tcache_count</code> and <code>glibc.malloc.tache_max</code></a></h3>
<p>These two tunables are interesting if we know that the target <code>glibc</code> uses
<code>tcache</code>s. If I knew that the vulnerable program was vulnerable to a double
free, I would probably go for a Fastbin Dup attack. The default number of
chunks that get linked into the <code>tcache</code> is <code>7</code>, however, if this was modified
to be something else, we'd have to do some debugging in production conditions
to determine the <code>tcache_count</code>. This tunable would affect the number of chunks
I <code>free()</code> in order to fill the <code>tcache</code> before I attempt to abuse the fastbin.</p>
<p><code>tcache_max</code> could also affect any attempts to go after heap metadata for
chunks linked into the unsortedbin. If <code>tcache_max</code>'s size overlapped with
sizes that are usually used for the unsortedbin, I would have to ensure that
the <code>tcache</code> is full before attempting to link chunks into the unsortedbin.</p>
<h3 id="glibcmallocarena_max-and-malloc_arena_max"><a class="header" href="#glibcmallocarena_max-and-malloc_arena_max"><code>glibc.malloc.arena_max</code> and <code>MALLOC_ARENA_MAX</code></a></h3>
<p>The <code>glibc.malloc.arena_max</code> tunable overrides anything set by
<code>MALLOC_ARENA_MAX</code>, but they achieve the same outcome. These two tunables set
the maximum number of arenas that can be used by the process across all threads
. For 32-bit systems, this value is twice the number of cores online and for
64-bit systems, this value is 8 times the number of cores online.</p>
<p>This is important if we're attempting to exploit the heap of a vulnerable
program that leverages multi-threaded operations. <code>MALLOC_ARENA_MAX</code> increases
the number of available memory pools that threads can allocate memory from.
A higher number of arenas helps to prevent thread contention for heap
resources as each thread has to lock the arena before allocating or <code>free()</code>ing
memory.</p>
<p>If we have local access to the vulnerable application, we can modify the
<code>MALLOC_ARENA_MAX</code> environment variable and set it to <code>1</code>. This forces each
thread of our target program to use the same arena, allowing us to possibly
exploit race conditions that might be present, or it could just make grooming
the heap easier. Either way, it's important to keep in mind how many arenas are
present when exploiting a program that leverages multi-threading as this will
guide our approach on how to effectively groom the heap across multiple arenas.</p>
<h2 id="references-15"><a class="header" href="#references-15">References</a></h2>
<ol>
<li><a href="https://seclists.org/bugtraq/2001/Jul/533">https://seclists.org/bugtraq/2001/Jul/533</a></li>
<li><a href="https://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf">https://www.blackhat.com/presentations/bh-europe-07/Sotirov/Presentation/bh-eu-07-sotirov-apr19.pdf</a></li>
<li><a href="https://azeria-labs.com/grooming-the-ios-kernel-heap/">https://azeria-labs.com/grooming-the-ios-kernel-heap/</a></li>
<li><a href="https://googleprojectzero.blogspot.com/2016/12/chrome-os-exploit-one-byte-overflow-and.html">https://googleprojectzero.blogspot.com/2016/12/chrome-os-exploit-one-byte-overflow-and.html</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Memory-Allocation-Tunables.html">https://www.gnu.org/software/libc/manual/html_node/Memory-Allocation-Tunables.html</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="race-conditions"><a class="header" href="#race-conditions">Race conditions</a></h1>
<p>Before we explain how <strong>race conditions</strong> can be used for exploitation, let's
first understand race conditions. Like with everything, there's a Common
Weakness Enumeration (CWE) entry for this vulnerability. The formal name for a
race condition is
<a href="common-vulnerabilities/race-conditions.html#references">Concurrent Execution using Shared Resource with Improper Synchronization</a>.
What this essentially means is that the vulnerable program is leveraging
parallelism, executing sections of code concurrently. Concurrent operations
exist in just about every modern application as it's much more effecient than
executing code sequentially and makes better use of available operating system
resources.</p>
<p>The problem in this situation, as stated in the title, is that the use of
resources across execution contexts is improperly synchronized. If you've dealt
with multi-processing or multi-threading before, you'll understand the need to
protect shared resources by enforcing atomicity and exclusivity. Two or more
execution contexts accessing or modifying a shared resource without the proper
use of synchronization mechanisms can lead to undefined behavior - and
undefined behavior can lead to program exploitation.</p>
<p>In the following sections, we'll discuss a few vulnerabilities that are
children of race conditions, with some examples on how they can be exploited.</p>
<h2 id="signal-handler-race-condition"><a class="header" href="#signal-handler-race-condition">Signal Handler Race Condition</a></h2>
<p><a href="common-vulnerabilities/race-conditions.html#references">Signal handler race conditions</a> can occur when signal handlers
registered for a process use non-reentrnant functions.
<a href="common-vulnerabilities/race-conditions.html#references">Reentrancy</a> is a property of a function or subroutine where
multiple invocations can safely run concurrently. Reentrant functions can be
interrupted in the middle of their execution and then safely re-entered
before previous invocations complete execution.</p>
<p>Non-reentrant functions that are commonly involved with this vulnerability
include <code>malloc()</code> and <code>free()</code> because they may use global or static data
structures for managing memory. This vulnerability manifests when a procedure
used for signal handling is registered for multiple signals and accesses the
shared resources during the handling of the signal. Below is some example code
that demonstrates this vulnerability, written by Michal Zalewski in the article
, <a href="common-vulnerabilities/race-conditions.html#references">Delivering Signals for Fun and Profit</a>:</p>
<pre><code class="language-c">/*********************************************************
 * This is a generic verbose signal handler - does some  *
 * logging and cleanup, probably calling other routines. *
 *********************************************************/

void sighndlr(int dummy) {
  syslog(LOG_NOTICE,user_dependent_data);
  // *** Initial cleanup code, calling the following somewhere:
  free(global_ptr2);
  free(global_ptr1);
  // *** 1 *** &gt;&gt; Additional clean-up code - unlink tmp files, etc &lt;&lt;
  exit(0);
}

  /**************************************************
   * This is a signal handler declaration somewhere *
   * at the beginning of main code.                 *
   **************************************************/

  signal(SIGHUP,sighndlr);
  signal(SIGTERM,sighndlr);

  // *** Other initialization routines, and global pointer
  // *** assignment somewhere in the code (we assume that
  // *** nnn is partially user-dependent, yyy does not have to be):

  global_ptr1=malloc(nnn); 
  global_ptr2=malloc(yyy);

  // *** 2 *** &gt;&gt; further processing, allocated memory &lt;&lt;
  // *** 2 *** &gt;&gt; is filled with any data, etc...     &lt;&lt;
</code></pre>
<p>In this example, Michael discusses that this code is vulnerable because both
<code>SIGHUP</code> and <code>SIGTERM</code>'s signal handlers execute <code>syslog()</code>, which uses
<code>malloc()</code>, and <code>free()</code> on the same shared resources. These functions are not
re-entrant because they operate on the same global structures, if one of the
signal handler functions were suspended while the other executed, it's possible
that, once <code>global_ptr2</code> is <code>free()</code>d, <code>syslog()</code> could be executed with
attacker-supplied data, re-using the free chunk and overwriting heap metadata.
Given the right conditions, this could lead to process exploitation.</p>
<h2 id="race-condition-within-a-thread"><a class="header" href="#race-condition-within-a-thread">Race Condition within a Thread</a></h2>
<p><a href="common-vulnerabilities/race-conditions.html#references">This particular example</a> is pretty straight-forward: two threads
of execution in a program use a resource simultaneously without proper
synchronization, possibly causing the threads to use invalid resources, leading
to an undefined program state.</p>
<p>Below is some example C code from CWE demonstrating this vulnerability:</p>
<pre><code class="language-c">int foo = 0;
int storenum(int num) {
	static int counter = 0;
	counter++;
	if (num &gt; foo) foo = num;
	return foo;
}
</code></pre>
<p>Again, pretty straight-foward. If this code executed concurrently using two
different threads, the value of <code>foo</code> after this procedure's <code>return</code>s is not
deterministic between different invocations of the program.</p>
<p>A more interesting and real-world example of this bug that achieves code
execution is demonstrated in the article,
<a href="common-vulnerabilities/race-conditions.html#references">Racing MIDI messages in Chrome</a>, by Google Project Zero. Some
background information: Chrome implements a user facing JavaScript API that
conducts inter-process communication (IPC) with a privilieged browser process
that provides brokered access to MIDI (Musical Instrument Digital Interface)
devices. Yeah, it's a surprise to me, too.</p>
<p>Anyways, the author goes to describe two bugs he found in the MIDI manager's
implementation, both vulnerable to a use-after-free (UAF) bug due to a race
condition. Because concurrent operations on objects in the heap are not
properly synchronized between threads, it's possible to coerce one of threads
to execute a virtual function of an already free object in the heap. The author
goes on to provide a proof of concept to obtain code execution using the first
bug, leveraging heap grooming to obtain a desirable heap state before forcing a
series of allocations to overwrite the <code>vtable</code> of the free object.</p>
<p>Without an adequate sensitive information disclosure, he is unable to
predicatbly redirect the process to obtain arbitrary code execution, however,
he still demonstrates that he can gain control of the <code>RIP</code>.</p>
<h2 id="time-of-check-time-of-use-toctou"><a class="header" href="#time-of-check-time-of-use-toctou">Time-of-check Time-of-use (TOCTOU)</a></h2>
<p><a href="common-vulnerabilities/race-conditions.html#references">Time-of-check time-of-use (TOCTOU)</a> is a classic vulnerability
that is a child of the race condition weakness. In summation, the program
checks the state of a resource, our permissions to access the resource, etc.,
before actually using it. The actual use of the resource comes <em>after</em> the
check, but what if the state of the resource changes before it's used? If we
check the resource but its properties change before we actually use it, our
program is liable to have undefined behavior.</p>
<p>An interesting example of this vulnerability and how it can be exploited was
covered in the <a href="common-vulnerabilities/race-conditions.html#references">logrotate</a> challenge of 35C3CTF 2019. In the
challenge, the <code>logrotate</code> binary rotates logs within the <code>/tmp/log</code> directory,
owned by the user. The <code>logrotate</code> program executes as <code>root</code>, but creates
files that are owned by <code>user:user</code> in the directory of <code>/tmp/log</code>. <code>logrotate</code>
executes <code>stat()</code> on the <code>/tmp/log</code> directory prior to using the directory
to write <code>/tmp/log/pwnme.log</code>, making <code>logrotate</code> vulnerable to a TOCTOU race
condition.</p>
<p>Armed with this information, the author of the writeup uses <code>inotify</code> to detect
when a change occurs for the <code>/tmp/log</code> directory. As soon as this happens, the
author creates a symbolic link for <code>/tmp/log</code> pointing it to
<code>/etc/bash_completion.d</code>. <code>logrotate</code> creates a <code>user</code> owned <code>pwnme.log</code> file
in <code>/etc/bash_completion.d</code> where the author writes his reverse-shell callback
shell script to. The next time <code>root</code> acquires a session, the reverse-shell
callback script is executed and the attacker is able to acquire a <code>root</code> shell.</p>
<p>The CTF challenge I just described is also a good example of the CWE: 
<a href="common-vulnerabilities/race-conditions.html#references">Symbolic Name not Mapping to Correct Object</a>.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>There are a few other vulnerabilities that are children of the general race
condition CWE such as:</p>
<ul>
<li>Context Switching Race Condition</li>
<li>Race Condition During Access to Alternate Channel</li>
<li>Permission Race Condition During Resource Copy</li>
</ul>
<p>While these are also interesting CWEs related to race conditions, the ones we
discussed above have pretty solid examples and demonstrations of real-world
application, which is the primary reason why I covered them.</p>
<h2 id="references-16"><a class="header" href="#references-16">References</a></h2>
<ol>
<li><a href="https://cwe.mitre.org/data/definitions/362.html">https://cwe.mitre.org/data/definitions/362.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/364.html">https://cwe.mitre.org/data/definitions/364.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)">https://en.wikipedia.org/wiki/Reentrancy_(computing)</a></li>
<li><a href="https://lcamtuf.coredump.cx/signals.txt">https://lcamtuf.coredump.cx/signals.txt</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/366.html">https://cwe.mitre.org/data/definitions/366.html</a></li>
<li><a href="https://googleprojectzero.blogspot.com/2016/02/racing-midi-messages-in-chrome.html">https://googleprojectzero.blogspot.com/2016/02/racing-midi-messages-in-chrome.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/367.html">https://cwe.mitre.org/data/definitions/367.html</a></li>
<li><a href="https://tech.feedyourhead.at/content/abusing-a-race-condition-in-logrotate-to-elevate-privileges">https://tech.feedyourhead.at/content/abusing-a-race-condition-in-logrotate-to-elevate-privileges</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/386.html">https://cwe.mitre.org/data/definitions/386.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/368.html">https://cwe.mitre.org/data/definitions/368.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/421.html">https://cwe.mitre.org/data/definitions/421.html</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploit-primitives"><a class="header" href="#exploit-primitives">Exploit primitives</a></h1>
<p>In this section, you'll find my notes on common exploit primitives and how to
implement them with different vulnerabilities. This section includes discussions
on the following topics:</p>
<ul>
<li>Arbitrary write primitives</li>
<li>Relative write primitives</li>
<li>Arbitrary read primitives</li>
<li>Chaining primitives to build an exploit</li>
<li>Using write primitives to escalate privileges</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arbitrary-write-primitives"><a class="header" href="#arbitrary-write-primitives">Arbitrary write primitives</a></h1>
<p>An <strong>arbitrary write primitive</strong>, formally known as a
<a href="exploit-primitives/arbitrary-write-primitives.html#references">Write-what-where condition</a>, is a condition where the attacker
has the ability to write an arbitrary value to an arbitrary location. An
attacker can implement this primitive by abusing an already existing
vulnerability. Here are some examples:</p>
<h3 id="a-hrefexploit-primitivesarbitrary-write-primitiveshtmlreferencesuse-of-externally-controlled-format-stringa"><a class="header" href="#a-hrefexploit-primitivesarbitrary-write-primitiveshtmlreferencesuse-of-externally-controlled-format-stringa"><a href="exploit-primitives/arbitrary-write-primitives.html#references">Use of Externally-Controlled Format String</a></a></h3>
<p>This isn't really an attacker implemented arbitrary write primitive as format
string vulnerabilities alone can allow attackers to write to arbitrary locations
, given the right circumstances. Essentially, the attacker is able to provide
a format string argument to the vulnerable program and this argument will be
used by functions like <code>printf</code>, <code>sprintf</code>, etc.</p>
<p>The issue here is that the format string identifiers <code>n</code>, <code>hn</code>, and <code>hhn</code> allow
the attacker to write the number of bytes written so far by the <code>printf</code> call
into an integer pointer parameter - <code>n</code> is an integer, <code>hn</code> is a short, and
<code>hhn</code> is a byte (char). The attacker can craft a format string to place their
write address(es) onto the stack, use format string identifiers like <code>c</code> and
<code>x</code> to write an arbitrary number of bytes to <code>stdout</code>, and then use <code>n</code>, <code>hn</code>,
or <code>hhn</code> with an offset (for example <code>$7hn</code> where <code>7</code> is the location of the
target address on the stack) to write arbitrary values to any writeable
location in program memory.</p>
<h3 id="a-hrefexploit-primitivesarbitrary-write-primitiveshtmlreferencesout-of-bounds-writea"><a class="header" href="#a-hrefexploit-primitivesarbitrary-write-primitiveshtmlreferencesout-of-bounds-writea"><a href="exploit-primitives/arbitrary-write-primitives.html#references">Out-of-bounds Write</a></a></h3>
<p>As demonstrated in the <a href="exploit-primitives/../common-vulnerabilities/house-of-force.html">House of Force</a>,
a heap buffer overflow can be used by an attacker to implement an arbitrary
write primitive. The attacker leverages the heap buffer overflow to overwrite
the value of the <code>top_chunk</code> and tricks malloc into relocating the top chunk to
a location directly above the attacker's desired arbitrary write target.
Finally, the attacker coerces the program to execute another <code>malloc</code> call,
creating a chunk directly overlapping the arbitrary write target. From here,
the attacker can now modify the user data of the chunk, writing arbitrary data
to the arbitrary write target.</p>
<h3 id="a-hrefexploit-primitivesarbitrary-write-primitiveshtmlreferencesuse-after-free-uafa"><a class="header" href="#a-hrefexploit-primitivesarbitrary-write-primitiveshtmlreferencesuse-after-free-uafa"><a href="exploit-primitives/arbitrary-write-primitives.html#references">Use-after-free (UAF)</a></a></h3>
<p>As we discussed in the <a href="exploit-primitives/../common-vulnerabilities/fastbin-dup.html">Fastbin Dup</a>, an attacker
can leverage a UAF to corrupt the heap metadata of a free chunk that has been
linked into the fastbin. The attacker overwrites the victim chunk's <code>fd</code>
pointer to point to a fake chunk that overlap's the attacker's desired
arbitrary write location. The attacker coerces the program to empty the fastbin
, eventually allowing the attacker to allocate a chunk that overlaps their
arbitrary write target. From here, the attacker can now modify the user data
of the chunk, writing arbitrary data to the arbitrary write target.</p>
<p>A UAF can also be leveraged to gain an arbitrary write by abusing <code>malloc()</code>'s
<code>unlink()</code>ing behavior. If the attacker has the ability to modify a chunk that
has been recently <code>free()</code>d and linked into the unsortedbin, the attacker can
corrupt the heap metadata of the victim unsortedbin chunk, specifically its
<code>fd</code> and <code>bk</code> pointers. The attacker overwrites the <code>fd</code> pointer of the victim
chunk to point to a fake chunk that overlaps the attacker's arbitrary write
location, and overwites the <code>bk</code> of the victim chunk to contain the arbitrary
data to be written to the arbitrary location. If the attacker can coerce
<code>malloc()</code> to consolidate the victim unsortedbin chunk with another free
chunk, the corrupted <code>bk</code> will be written to the fake chunk overlapping the
attacker's arbitrary write target. A couple of details regarding this method
have been left out, including mitigations that have been applied to prevent
this as well as how to gain code execution using this technique. More detail
is provided in the
<a href="exploit-primitives/../exploit-mitigations/safe-list-unlinking.html">Safe list unlinking</a> discussion.</p>
<h3 id="a-hrefexploit-primitivesarbitrary-write-primitiveshtmlreferencesfree-of-memory-not-on-the-heapa"><a class="header" href="#a-hrefexploit-primitivesarbitrary-write-primitiveshtmlreferencesfree-of-memory-not-on-the-heapa"><a href="exploit-primitives/arbitrary-write-primitives.html#references">Free of Memory not on the Heap</a></a></h3>
<p>This one is pretty interesting. Essentially, a <code>free()</code> call gets pointed to a
chunk that's not on the heap and, if nothing fails <code>free()</code>'s chunk checks,
the location in memory that was just <code>free()</code>d gets linked into one of the
arena's bins. I say this is particularly interesting because there could be
some scenario in which chunk pointers are contained in some data structure
located on either the stack or in global data, such as <code>.data</code> or <code>.bss</code>. If
the attacker were able to corrupt one of these pointers before it gets
<code>free()</code>d, the attacker could coerce <code>free()</code> into linking an arbitrary
location in memory into a bin. The attacker could then coerce the program to
call <code>malloc()</code> enough times until the attacker acquires a pointer to a chunk
overlapping their arbitrary write target. From here, the attacker could modify
the fake chunk's user data, overwriting their arbitrary write target.</p>
<h2 id="references-17"><a class="header" href="#references-17">References</a></h2>
<ol>
<li><a href="https://cwe.mitre.org/data/definitions/123.html">https://cwe.mitre.org/data/definitions/123.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/134.html">https://cwe.mitre.org/data/definitions/134.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/787.html">https://cwe.mitre.org/data/definitions/787.html</a></li>
<li><a href="exploit-primitives/../common-vulnerabilities/house-of-force.html">House of Force</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/416.html">https://cwe.mitre.org/data/definitions/416.html</a></li>
<li><a href="exploit-primitives/../common-vulnerabilities/fastbin-dup.html">Fastbin Dup</a></li>
<li><a href="exploit-primitives/../exploit-mitigations/safe-list-unlinking.html">Safe list unlinking</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/590.html">https://cwe.mitre.org/data/definitions/590.html</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="relative-write-primitive"><a class="header" href="#relative-write-primitive">Relative write primitive</a></h1>
<p>The <strong>relative write primitive</strong> does not have a formal Common Weakness
Enumeration (CWE) Weakness ID, making it a bit harder to find great resources
that adequately cover this primitive. Nonetheless, this is still a pretty
powerful primitive and, under the right conditions, can lead to pretty reliable
exploits.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>A relative write primitive is a condition in which the attacker can control
sensitive program information via a memory corruption vulnerability from a
relative location to the targeted sensitive information. Basically, the
attacker can expect that their target memory location for corruption is at a
specific offset when providing data to the program. Given this definition, both
<strong>stack buffer overflows</strong> and <strong>heap buffer overflows</strong> can qualify as
relative write primitives.</p>
<p>In a stack buffer overflow, the attacker can expect that the
<code>saved frame pointer</code> and <code>return address</code> of a program stack frame will always
be in the same location. Thus, when they've determined the offset of the buffer
they're overflowing relative to their targeted write location, they can use
their relative write primitive to reliably corrupt a stack frame, providing the
attacker control over process execution. A good example of reliable
exploitation that uses a relative write primitive is the <strong>funge-and-games</strong>
CTF challenge from Cyberstakes 2017. The challenge allows us to provide a
Befunge program to the vulnerable binary, simulating operations that would be
executed by a Befunge interpreter. The vulnerability lies in the fact that no
bounds checking is conducted when the Befunge interpreter references its
internal <code>stack</code> data structures, allowing an attacker to conduct out-of-bounds
reads and writes. The attacker can use this to reliably corrupt the
<code>return address</code> of the program's stack frames using a relative write
primitive.</p>
<p>Likewise, a heap buffer overflow can be used by an attacker to achieve similar
objectives. If the attacker is aware that sensitive program information is
contained within the heap chunk that they are able to overflow into, they can
use this <strong>intra-chunk heap overflow</strong>, or relative write primitive, to
reliably corrupt the sensitive information contained within the current heap
chunk. This bug class and its reliability is discussed further in
<a href="exploit-primitives/relative-write-primitives.html#references">this Google Project Zero article</a>.</p>
<h2 id="a-hrefexploit-primitivesrelative-write-primitiveshtmlreferenceshouse-of-romana"><a class="header" href="#a-hrefexploit-primitivesrelative-write-primitiveshtmlreferenceshouse-of-romana"><a href="exploit-primitives/relative-write-primitives.html#references">House of Roman</a></a></h2>
<p>The <strong>House of Roman</strong> is a great example of using relative overwrites within
the heap to gain code execution. This technique doesn't require a specific
heap memory corruption vulnerability to exist, it could be either a heap
overflow or use-after-free (UAF). The attacker just needs to be able to edit
a couple of pointers contained within the user data and metadata of heap chunks
, using heap feng shui to adequately groom the heap for deterministic relative
writes.</p>
<p>The attacker grooms the heap to obtain a favorable state and then uses their
relative write primitive to obtain a fastbin chunk that overlaps the
<code>__malloc_hook</code> function pointer in <code>glibc</code>. This is possible because the
attacker abuses the nature of the unsortedbin to acquire <code>glibc</code> pointers in
the <code>fd</code> and <code>bk</code> pointers of a chunk, and then edits the last 4 bits of these
pointers to point to a fake chunk that overlaps the <code>__malloc_hook</code>.</p>
<p>The attacker is also able to get this fake chunk linked into the fastbin by
editing a preceding free chunk that is also in the fastbin, modifying the last
4 bits of the chunk's <code>fd</code> pointer to link the chunk that contains the address
of the <code>__malloc_hook</code> in to the fastbin. This is possible because, as we
mentioned earlier, the attacker uses heap feng shui to land target chunks at
specific offests. In this case, the chunk with <code>glibc</code> pointers is at an
offset of <code>0x100</code> from the preceding chunk mentioned.</p>
<p>The attacker conducts an unsortedbin attack to overwrite the <code>__malloc_hook</code>
with an address of <code>main_arena</code>. Again, only a couple of bytes are required to
be overwritten within the <code>bk</code> pointer of the unsortedbin chunk in order to
point the <code>bk</code> to <code>__malloc_hook</code>. Once the attacker writes a <code>main_arena</code>
address to the <code>__malloc_hook</code>, the attacker uses the previously mentioned
fastbin chunk that overlaps the <code>__malloc_hook</code> to edit the last couple of
bytes in the written information, overwriting the <code>__malloc_hook</code> with the
address of <code>system()</code> or a <code>one_gadget</code>.</p>
<p>Of note, due the amount of randomness introduced by ASLR, this technique is
only really successful if the attacker is able to brute force the location of
<code>glibc</code> data structures. If the program crashes after each attempt, the
likelihood of this technique working is pretty low. Despite all of this, the
<strong>House of Roman</strong> is a good technique to demonstrate the power of relative
write primitives and how they can be chained to gain code execution.</p>
<h2 id="references-18"><a class="header" href="#references-18">References</a></h2>
<ol>
<li><a href="https://googleprojectzero.blogspot.com/2015/06/what-is-good-memory-corruption.html">https://googleprojectzero.blogspot.com/2015/06/what-is-good-memory-corruption.html</a></li>
<li><a href="https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c">https://github.com/shellphish/how2heap/blob/master/glibc_2.23/house_of_roman.c</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arbitrary-read-primitives"><a class="header" href="#arbitrary-read-primitives">Arbitrary read primitives</a></h1>
<p>An <strong>arbitrary read primitive</strong> is a condition in which the attacker can read
any location within a process's virtual memory. A close formal definition for
this condition provided by the Common Weakness Enumeration (CWE) list is
<a href="exploit-primitives/arbitrary-read-primitives.html#references">Untrusted Pointer Dereference</a>. This definition describes a
condition for a program in which it will dereference the value of any pointer
provided, whether it be from a trusted or untrusted source. An attacker can
find usefulness from this condition if the program prints the content of the
pointer provided. Below are some examples of how an attacker can implement or
utilize an arbitrary read primitive present within a program.</p>
<h2 id="a-hrefexploit-primitivesarbitrary-read-primitiveshtmlreferencesuse-of-externally-controlled-format-stringa"><a class="header" href="#a-hrefexploit-primitivesarbitrary-read-primitiveshtmlreferencesuse-of-externally-controlled-format-stringa"><a href="exploit-primitives/arbitrary-read-primitives.html#references">Use of Externally-Controlled Format String</a></a></h2>
<p>Just like in our <a href="exploit-primitives/./arbitrary-write-primitives.html">Arbitrary write primitives</a>
discussion, we note that a format string vulnerability is not a condition that
is implemented by an attacker, it's just present due to programmer error. The
condition itself, however, is still useful for an attacker to arbitrarily read
memory from any location in the process, given the right conditions.</p>
<p>Like our previous discussion, the attacker can provide an address in their
forged format string in order to place that address onto the stack for their
vulnerable <code>printf()</code> call. Also like our previous discussion, the attacker
must know the offset of their placed address on the stack during the call to
<code>printf()</code>. Unlike our previous discussion, the attacker will have to use
different format string identifiers in order to print the contents of the
address they placed onto the stack. The most commonly used format string
identifiers used by attackers to dump information from memory are:</p>
<ul>
<li><code>p</code> - <code>void*</code></li>
<li><code>x</code> - <code>unsigned int</code></li>
<li><code>s</code> - <code>null terminated string</code></li>
</ul>
<h2 id="a-hrefexploit-primitivesarbitrary-read-primitiveshtmlreferencesuse-of-out-of-range-pointer-offseta"><a class="header" href="#a-hrefexploit-primitivesarbitrary-read-primitiveshtmlreferencesuse-of-out-of-range-pointer-offseta"><a href="exploit-primitives/arbitrary-read-primitives.html#references">Use of Out-of-range Pointer Offset</a></a></h2>
<p>This particular condition is a child of
<a href="exploit-primitives/arbitrary-read-primitives.html#references">Improper Restriction of Operations within the Bounds of a Memory Buffer</a>,
however, I feel like this is more applicable to this discussion about arbitrary
read primitives. The most important portion of this condition's Extended
Description is the statement:</p>
<blockquote>
<p>If an attacker can control or influence the offset so that it points outside
of the intended boundaries of the structure, then the attacker may be able to
read or write to memory locations that are used elsewhere in the program.</p>
</blockquote>
<p>For our discussion, we're interested in the implementation of an arbitrary read
primitive using the condition described above. A good example of implementing
an arbitrary read primitive is the <code>feap</code> challenge from
<a href="exploit-primitives/arbitrary-read-primitives.html#references">ASIS CTF Quals 2016</a>. The arbitrary read primitive for this
challenge exists in the <code>print_note</code> function of the vulnerable executable. The
<code>print_note</code> function conducts no bounds checking when indexing into the
<code>notes</code> array, allowing the attacker to provide array indices that are outside
the bounds of the <code>notes</code> array. This ultimately leads to the program treating
these out of bounds locations as <code>note</code> structures, and attempts to call
<code>printf()</code> on what it believes to be a <code>note</code>'s <code>title</code> attribute.</p>
<p>Coincidentally, the <code>note_sizes</code> array resides directly below the <code>notes</code> array
that the attacker is able to read past. The attacker is able to forge a valid
pointer in memory in the <code>note_sizes</code> array by creating a note of a particular
size: their target address - <code>0x40</code> (to account for the bytes added by the
program). The attacker then reads past the <code>notes</code> array and fools the program
into calling <code>printf()</code> on the valid memory address contained within
<code>note_sizes</code> - the program thinks this pointer offset is a valid <code>note</code> struct.
This condition in this CTF challenge provides the attacker the ability to
implement an arbitrary read primitive.</p>
<h2 id="so-what-are-arbitrary-read-primitives-good-for"><a class="header" href="#so-what-are-arbitrary-read-primitives-good-for">So what are arbitrary read primitives good for?</a></h2>
<p>Attackers most commonly use <strong>arbitrary read primitives</strong> to leak sensitive
program information, allowing them to bypass mitigations such as ASLR, PIE,
stack canaries, and possibly even pointer mangling. If the attacker can conduct
an arbitrary read of data from the stack, they will most likely be able to
expose <code>glibc</code> and program pointers or return addresses stored on the stack,
allowing them to calculate the base addresses for the <code>glibc</code> and program
segments in the process's virtual memory mapping. Attackers would also have an
interest in leaking heap pointer information in order to derive the base of the
heap in memory, especially if their method of gaining code execution is via a
heap memory corruption vulnerability.</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>An <strong>arbitrary read primitive</strong> is only useful if an attacker knows what
information they want and where to get it. Attackers must also know how to use
an initial exposure to guide succeeding exposures - you won't always know the
exact address of your arbitrary read target, and you might need to expose the
contents of other data structures in memory in order to find it.</p>
<p>Take for example a vulnerable non-PIE binary where an attacker can implement an
arbitrary read primitive. The attacker doesn't know where the stack is, but
they do know the location of the Global Offset Table (GOT), allowing them to
leak <code>glibc</code> information for functions that have been called and their address
within <code>glibc</code> resolved - from here an attacker can now derive the base of
<code>glibc</code> in process memory. Now knowing the base of <code>glibc</code> in memory, if the
attacker wished to locate the base of the heap, they would be able to target
the <code>main_arena</code> in <code>glibc</code>. Using the <code>main_arena</code>, the attacker can leak the
location of one of the bins, allowing them the ability to derive the base of
the heap in memory. The usefulness of an <strong>arbitrary read primitive</strong> relies on
its user's understanding of the state of the process when the primitive is
implemented and the user's knowledge of where important data structures are
stored in process memory.</p>
<h2 id="references-19"><a class="header" href="#references-19">References</a></h2>
<ol>
<li><a href="https://cwe.mitre.org/data/definitions/822.html">https://cwe.mitre.org/data/definitions/822.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/134.html">https://cwe.mitre.org/data/definitions/134.html</a></li>
<li><a href="exploit-primitives/./arbitrary-write-primitives.html">Arbitrary write primitives</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/823.html">https://cwe.mitre.org/data/definitions/823.html</a></li>
<li><a href="https://ctftime.org/task/2370">https://ctftime.org/task/2370</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chaining-primitives"><a class="header" href="#chaining-primitives">Chaining primitives</a></h1>
<p>As stated in the <a href="exploit-primitives/./arbitrary-read-primitives.html">previous discussion</a>, an
attacker can acquire these primitives but in order for these primitives to be
useful, an attacker has to understand the implications and side-effects of using
these primitives. Some of the best examples for chaining these primitives to
build an exploit in the <strong>challenges</strong> directory of this repository are the
<code>funge-and-games</code> challenge from Cyberstakes 2017 and the <code>feap</code> challenge from
<a href="exploit-primitives/chaining-primitives.html#references">ASIS CTF Quals 2016</a>.</p>
<p>In the <code>funge-and-games</code> challenge we use a relative read / write primitive on
the stack to leak <code>__libc_start_main+231</code>, a symbol that we can expect to
always be present in the stack if a target is compiled with <code>glibc</code>. It might
be a different offset of <code>__libc_start_main</code> across different versions of
<code>glibc</code>, but this is the subroutine called by <code>_start</code> of the ELF that then
calls <code>main</code> - a pretty important piece of the pie. Leaking this symbol from
the stack allows us to derive the base address of <code>glibc</code> in process memory,
and from here we derive the location of our <code>one_gadget</code>. We use our relative
write primitive to overwrite the return address of <code>main</code>'s stack frame with
the address of <code>_start</code>. This provides us the ability to restart the program
from a clean state, and from here we can provide another payload to the
program. Finally, we use the same buffer indexing vulnerability to overwrite
the return address of <code>simulate</code> to our <code>one_gadget</code>, and when the program
exits the simulator we gain an interactive shell.</p>
<p>For the <code>feap</code> challenge, I've already discussed how the attacker implements an
arbitrary read primitive in <a href="exploit-primitives/chaining-primitives.html#references">[1]</a>. What's important is that the
attacker utilizes the arbitrary read primitive to expose some sensitive and
important information for building the final exploit. The attacker exposes the
base address of the heap, using the previously mentioned arbitrary read
primitive to read a heap address contained within the <code>.bss</code> section of the
ELF. This is possible because the vulnerable ELF is not a position independent
executable (PIE), we can always expect the base of the <code>.bss</code> section to loaded
into the same location in virtual memory upon each invocation of the program.
Next, the attacker does the same to uncover <code>puts@GOT</code> (symbol contained within
the Global Offset Table (GOT)). This is important because the attacker needs to
derive the base address of <code>glibc</code> in virtual memory in order to calculate the
location of the <code>system()</code> symbol. The attacker reads <code>puts@GOT</code> because, as
stated earlier, the target ELF is not a PIE - the GOT will always be loaded
into the same location in virtual memory each time the program is invoked.
Finally, the attacker implements an arbitrary write primitive using
<a href="exploit-primitives/../common-vulnerabilities/house-of-force.html">The House of Force</a> to write the address of
<code>system@glibc</code> to <code>free@GOT</code>. The next time <code>free@plt</code> is called on a chunk in
the heap, the call will resolve to <code>system</code> and the memory of the chunk will be
passed as an argument to <code>system</code>. The attacker uses this to <code>free()</code> a chunk
containing <code>&quot;/bin/sh&quot;</code> in its user data, causing the program to execute
<code>system(&quot;/bin/sh&quot;)</code>.</p>
<h2 id="references-20"><a class="header" href="#references-20">References</a></h2>
<ol>
<li><a href="exploit-primitives/./arbitrary-read-primitives.html">Arbitrary read primitives</a></li>
<li><a href="https://ctftime.org/task/2370">https://ctftime.org/task/2370</a></li>
<li><a href="exploit-primitives/../common-vulnerabilities/house-of-force.html">The House of Force</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="escalating-privileges"><a class="header" href="#escalating-privileges">Escalating privileges</a></h1>
<p>We've covered how an arbitrary write primitive can be used to escalate
privileges or execute arbitrary code in a lot of these different discussions,
the Houses covered in our heap exploitation section, for example. In all of
these examples, once the attacker has all the information they need from
previous sensitive information disclosures to build their final payload, these
techniques usually conduct one final, important write to gain control of the
vulnerable process in order to execute arbitrary code. In this section we'll
list some interesting targets that attackers write to to gain control of the
process. This list will not be all-encompassing as I'm sure there are plenty
of other candidates that can be used to hijack the process, these are just ones
that are more popular within the community.</p>
<h3 id="global-offset-table"><a class="header" href="#global-offset-table">Global Offset Table</a></h3>
<p>The GOT is a common location for attackers to target given they have an
arbitrary write primitive. Whenever a program calls functions from linked
libraries, the GOT will be used by the program to either resolve the symbol or
call the symbol stored there. Attackers will commonly overwrite a GOT entry
with the symbol of a different function they want the program to call, usually
ensuring that the next couple of call operations conducted by the program
include the now corrupted GOT entry. While this is a common target for
arbitrary writes to gain arbitrary code execution, keep in mind that <strong>full
RELRO</strong> mitigates this tactic, resolving all entries within the GOT and setting
it to read-only before the program starts. <a href="exploit-primitives/escalating-privileges.html#references">[2]</a></p>
<h4 id="partial-relro"><a class="header" href="#partial-relro">Partial RELRO</a></h4>
<p>In order to complete our knowledge about the Relocation Read-Only (RELRO)
protection mechanism, Partial RELRO is a security mitigation where the
Global Offset Table is relocated to reside <em>above</em> the <code>.bss</code> section. There
existed previous methods of attacking the GOT where attackers would utilize
a buffer overflow of a global variable contained in the <code>.bss</code> section to
corrupt the GOT - for some reason the <code>.bss</code> used to reside above the GOT
in ELF programs.</p>
<p>Compilers now enforce Partial RELRO by default, placing the GOT above the
<code>.bss</code> in order to mitigate this attack surface. <a href="exploit-primitives/escalating-privileges.html#references">[7]</a></p>
<h3 id="initialglibc"><a class="header" href="#initialglibc"><code>initial@glibc</code></a></h3>
<p>This write target is pretty cool. The <code>initial</code> data structure in <code>glibc</code> is
a read/writeable segment in memory that is used to contain/register sensitive
information that <code>glibc</code> tracks for the current process. For an attacker, the
more interesting information they would most likely go after are the function
pointers registered by <code>atexit()</code>. My understanding of this data structure and
its use to gain control of the process is derived from <strong>0x00 CTF 2017</strong>'s
challenge, &quot;<strong>Left</strong>&quot;. <a href="exploit-primitives/escalating-privileges.html#references">[3]</a> In the Left challenge, the program
gives the attacker a <code>glibc</code> leak, one arbitrary read and one arbitrary write
and then calls <code>exit</code> immediately after. The attacker must use this arbitrary
read to leak the mangled pointer of <code>_dl_fini</code> stored in the <code>initial</code> section
of <code>glibc</code>. <code>_dl_fini</code> is a function pointer that is always registered in the
<code>initial</code> section of <code>glibc</code>, and all of the function pointers stored in
<code>initial</code> are unmangled and executed when <code>exit</code> is called. The attacker uses
the exposed, mangled pointer of <code>_dl_fini</code> to derive the secret stored in
Thread Local Storage (TLS) and then mangles a <code>one_gadget</code> address in the
correct manner to forge a valid <code>initial</code> entry. The attacker then uses a
single arbitrary write to overwrite the <code>_dl_fini</code> pointer in <code>initial</code>. Once
the program calls <code>exit</code>, the <code>one_gadget</code> entry in <code>initial</code> will be executed,
allowing the attacker to gain an interactive shell.</p>
<h3 id="_io_list_allglibc"><a class="header" href="#_io_list_allglibc"><code>_IO_list_all@glibc</code></a></h3>
<p>This is an interesting one as well, and its usefulness is showcased in
<a href="exploit-primitives/../common-vulnerabilities/house-of-orange.html">The House of Orange</a>. In The
House of Orange, the attacker uses the write primitive provided by an
Unsortedbin Attack to write a <code>main_arena</code> address to the <code>_IO_list_all</code> symbol
in <code>glibc</code>. This symbol keeps track of all the open <code>_IO_FILE</code> structures for
the process, and the attacker uses this to kick off some File Stream Oriented
Programming to gain control of the process for arbitrary code execution.
<a href="exploit-primitives/escalating-privileges.html#references">[5]</a> The attacker forces the process to experience a <code>SIGABRT</code>
rasied by checks in <code>malloc()</code> which leads to <code>glibc</code> attempting to call the
<code>overflow</code> function of all <code>_IO_FILE</code> structures present in the linked list of
<code>_IO_list_all</code>. Because <code>_IO_list_all</code> now points to the <code>main_arena</code>, it
attempts to treat the <code>main_arena</code> as an <code>_IO_FILE</code> structure and attempts to
execute the <code>overflow</code> function registered in its <code>vtable</code>. This obviously fails
but, instead of failing completely, <code>glibc</code> just moves onto the next <code>_IO_FILE</code>
structure pointed to by <code>main_arena</code>'s <code>chain</code> attribute (since <code>glibc</code> assumes
<code>main_arena</code> is an <code>_IO_FILE</code> structure at this point). It just so happens that
this <code>chain</code> attribute points to the <code>smallbin</code>, a location where the attacker
controls the data. Using this, the attacker ensures that a fake, but valid,
<code>_IO_FILE</code> structure resides in this location and fools <code>glibc</code> into calling
<code>overflow</code> from its forged <code>vtable</code>. The attacker ensures that <code>overflow</code> just
ends up being a pointer to <code>system@glibc</code>, and the argument being passed to
this call is the current <code>_IO_FILE</code> struct. The attacker ensures that
<code>&quot;/bin/sh&quot;</code> resides at the first word of bytes in the <code>_IO_FILE</code> struct, thus
fooling the process into executing <code>system(&quot;/bin/sh&quot;)</code>.</p>
<h3 id="__malloc_hookglibc-and-__free_hookglibc"><a class="header" href="#__malloc_hookglibc-and-__free_hookglibc"><code>__malloc_hook@glibc</code> and <code>__free_hook@glibc</code></a></h3>
<p>And, finally, we have our usual suspects, the <code>__malloc_hook</code> and the
<code>__free_hook</code>. These are kinda the easy button of arbitrary write targets
within <code>glibc</code> if we know that our target program is making calls to <code>malloc</code>
and <code>free</code> in the future. As discussed in
<a href="exploit-primitives/../common-vulnerabilities/house-of-force.html">The House of Force</a>, the
<code>__malloc_hook</code> and the <code>__free_hook</code> are symbols in <code>glibc</code> that were
originally implemented to allow programmers the ability to register functions
that will be executed when calls <code>malloc()</code> or <code>free()</code> are made. The thought
process was to allow programmers the ability to gather memory usage statistics
or to install their own versions of these functions, etc.</p>
<p>Attackers use these hooks to redirect program execution with just one arbitrary
write, and they usually overwrite these locations with the address of a
<code>one_gadget</code> or the symbol of <code>system()</code>. It's not outside the realm of
possibility, however, that they could use these hooks to pivot to the location
of a <code>ROP</code> chain which could possibly lead to the execution of more complex
shellcode.</p>
<h3 id="honorable-mention-_dl_open_hookglibc"><a class="header" href="#honorable-mention-_dl_open_hookglibc">Honorable mention: <code>_dl_open_hook@glibc</code></a></h3>
<p>I won't go into too much detail with this one seeing as we've covered so many
other options already, but I recently just learned about this technique which
surprisingly doesn't have a lot of coverage on the internet. In
POCORGTFO 2018 <a href="exploit-primitives/escalating-privileges.html#references">[6]</a>, an author covers what they call the
&quot;House of Fun&quot;, a <code>frontlink</code> attack in <code>malloc()</code> that people assumed was
mitigated but actually went unpatched until <code>glibc 2.30</code>. With the arbitrary
write that they gain through this technique, the attackers target
<code>_dl_open_hook</code> which is a hook where programmers can register a function
pointer to be called when <code>dlopen()</code> is called by the program. A little known
fact is that <code>malloc_printerr</code> when causes a <code>SIGABRT</code> and the program attempts
to dump the memory mapping of the process, it needs to call <code>dlopen</code> on
<code>libgcc_s.so.1</code> in order to access the <code>__backtrace</code> function. With this in
mind, the attackers write a <code>one_gadget</code> to <code>_dl_open_hook-&gt;dlopen_mode</code> and
force <code>malloc()</code> to encounter corrupted heap metadata, causing it to call
<code>malloc_printerr</code> which leads to <code>dlopen()</code> which leads to the program
executing <code>sys_execve(&quot;/bin/sh&quot;)</code>.</p>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>As we can see, viable write targets to gain arbitrary code execution within a
process are aplenty. It's up to the attacker to ensure they understand what
conditions need to be present in order to get reliable code execution - there's
also some creativity required.</p>
<h2 id="references-21"><a class="header" href="#references-21">References</a></h2>
<ol>
<li><a href="exploit-primitives/../common-vulnerabilities/house-of-force.html">The House of Force</a></li>
<li><a href="https://ctf101.org/binary-exploitation/relocation-read-only/">https://ctf101.org/binary-exploitation/relocation-read-only/</a></li>
<li><a href="https://ctftime.org/writeup/8385">https://ctftime.org/writeup/8385</a></li>
<li><a href="exploit-primitives/../common-vulnerabilities/house-of-orange.html">The House of Orange</a></li>
<li><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/fsop/">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/io_file/fsop/</a></li>
<li><a href="https://www.alchemistowl.org/pocorgtfo/pocorgtfo18.pdf">https://www.alchemistowl.org/pocorgtfo/pocorgtfo18.pdf</a></li>
<li><a href="https://ctf101.org/binary-exploitation/relocation-read-only/">https://ctf101.org/binary-exploitation/relocation-read-only/</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return-oriented-programming"><a class="header" href="#return-oriented-programming">Return oriented programming</a></h1>
<p>In this section, you'll find my notes on return oriented programming (ROP) and
how to leverage the technique for exploit development. This section includes
discussions on the following topics:</p>
<ul>
<li>Using ROP/JOP to overcome ASLR/NX</li>
<li>Finding gadgets</li>
<li>Calling libc functions / syscalls</li>
<li>Chaining gadgets to execute code</li>
<li>Using ROP/JOP to execute arbitrary shellcode</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overcoming-aslrnx"><a class="header" href="#overcoming-aslrnx">Overcoming ASLR/NX</a></h1>
<h2 id="what-is-rop"><a class="header" href="#what-is-rop">What is ROP?</a></h2>
<p><strong>The below explanation is tailored towards x86 return-oriented programming.
For amd64, the register names would change from E%%-&gt;R%% and word size would be
8 bytes instead of 4.</strong></p>
<p>In a normal program, machine instructions are located within the <code>.text</code>
segment of the process's memory. Each instruction is a pattern of bytes to be
interpreted by the processor to change the program's state. The instruction
pointer, <code>EIP</code>, governs the sequential flow of a program, pointing to the
instruction that is to be fetched next and advanced by the processor after
each instruction is executed.</p>
<p>A return-oriented program is a particular layout of the <code>stack</code> segment within
a process - the <code>stack</code> segment being the location within the process's
memory that is pointed to by the <code>ESP</code> (more on this later in stack pivoting).
Return-oriented instructions are words on the <code>stack</code> that point to an
instruction sequence within the process's memory. In return-oriented
programming, the <code>stack</code> pointer, <code>ESP</code>, now governs the control flow of the
program and points to the next instruction sequence that will be fetched and
executed.</p>
<p>The execution of return-oriented programs is as follows:</p>
<ul>
<li>The word on the <code>stack</code> that the <code>ESP</code> points to is read and used as the
new value for the <code>EIP</code>.</li>
<li>The <code>ESP</code> is incremented by 4 bytes, pointing to the next word on the stack.</li>
<li>The processor completes execution of the instruction sequence and, if the
provided instruction sequence was a <code>ROP</code> gadget, a <code>ret</code> would be executed to
repeat this process.</li>
</ul>
<p>In contrast to normal programs, the <code>ret</code> instruction at the end of each
instruction sequence pointed to on the <code>stack</code> induces fetch-and-decode
behavior.</p>
<h2 id="what-is-jop"><a class="header" href="#what-is-jop">What is JOP?</a></h2>
<p>With the popularity of <code>ROP</code>, some work has been done to protect against or
mitigate attacks that leverage <code>ROP</code> to deliver malicious payloads and gain
code execution. Proposed defenses include detection of consecutive <code>ret</code>
instructions that are suspected <code>ROP</code> gadgets <a href="return-oriented-programming/aslr-nx.html#references">[2]</a>, detection of
<code>ROP</code>-inherent behaviors like continuously popping return addresses that always
point to the same memory space <a href="return-oriented-programming/aslr-nx.html#references">[3]</a>, and the elimination of all
<code>ret</code> instructions within a program to remove return-oriented gadgets
<a href="return-oriented-programming/aslr-nx.html#references">[4]</a>.</p>
<p>Unlike <code>ROP</code>, Jump-oriented programming (<code>JOP</code>) does not rely upon the <code>stack</code>
or <code>ret</code> instructions for gadget discovery and gadget chaining. Like <code>ROP</code>,
<code>JOP</code> finds its gadgets within executable code snippets within the target
binary or in the standard C library, however, <code>JOP</code> gadgets end with an
indirect <code>jmp</code> instruction. To chain gadgets together, <code>JOP</code> specifies two
types of gadgets: the <code>dispatcher gadget</code> and <code>functional gadgets</code>.</p>
<p>In <code>ROP</code>, gadgets are stored on the <code>stack</code> and the <code>ESP</code> acts as the program
counter for a return-oriented program. In <code>JOP</code>, the program counter is any
register that points into the <code>dispatch table</code>, and control flow is dictated by
the <code>dispatcher gadget</code> that executes the sequence of gadgets within the
<code>dispatch table</code>. Each entry within the <code>dispatch table</code> points to a
<code>functional gadget</code>. In the corpus of gadgets derived from the code contained
within a target binary or shared library, the <code>dispatcher gadget</code> is comprised
of jump-oriented gadgets that advance the program counter within the dispatch
table and incorporate the least frequently used registers. This is done to
avoid having the program counter register subjected to side effects of
instructions in <code>functional gadgets</code>.</p>
<p><code>Functional gadgets</code> within jump-oriented programming are useful instructions
ending in a sequence that will load the instruction pointer with the result of
a known expression. The primary requirement for <code>functional gadgets</code> is that,
by the time the gadget's <code>jmp %</code> instruction is executed, the <code>jmp</code> must
evaluate to the address of the <code>dispatcher gadget</code> or to another gadget that
leads to the <code>dispatcher</code>. Sequences that end in a <code>call</code> instruction are also
viable candidates for jump-oriented gadgets.</p>
<h3 id="so-how-do-we-gain-control-flow"><a class="header" href="#so-how-do-we-gain-control-flow">So how do we gain control flow?</a></h3>
<p>Let's assume we've exploited some vulnerability within a target binary to gain
control of the <code>EIP</code>. While <code>ROP</code> only requires control over the <code>EIP</code> and the
<code>ESP</code>, <code>JOP</code> requires control over the <code>EIP</code> and any memory locations or
registers necessary to run the <code>dispatcher gadget</code>. To do this, an
<code>initializer gadget</code> is used to fill the relevant registers before jumping to
the <code>dispatcher gadget</code>.</p>
<h3 id="why-would-i-use-jop-over-rop"><a class="header" href="#why-would-i-use-jop-over-rop">Why would I use JOP over ROP?</a></h3>
<p>As stated earlier, defenses have been proposed to detect <code>ROP</code> behavior within
a compromised binary. <code>JOP</code>'s lack of reliance on the <code>stack</code> and use of <code>jmp</code>
and <code>call</code> instructions for control flow make it much harder to detect and
create identifiers for. If it is known that your target implements some sort of
protection mechanism to thwart <code>ROP</code>, <code>JOP</code> is still an option to gain control
over a target and execute code.</p>
<h2 id="does-a-ropjop-gadget-have-to-be-specifically-from-the-text-segment-of-a-binary-what-are-the-characteristics-of-a-usable-gadget"><a class="header" href="#does-a-ropjop-gadget-have-to-be-specifically-from-the-text-segment-of-a-binary-what-are-the-characteristics-of-a-usable-gadget">Does a ROP/JOP gadget have to be specifically from the <code>.text</code> segment of a binary? What are the characteristics of a usable gadget?</a></h2>
<p><em>&quot;[A] gadget is an arrangement of words on the stack, both pointers to
instruction sequences and immediate data words, that when invoked accomplishes
some well-defined task.&quot;</em> <a href="return-oriented-programming/aslr-nx.html#references">[1]</a></p>
<p>The above quote suggests that <code>ROP</code> gadgets can be interpreted as a grouping of
words including one or more instruction sequences and immediate values that
encode a logical unit. Gadgets can be built from short instruction sequences
within target binaries, but they also can be derived from libraries used by
target binaries - a commonly used library being the standard C library.</p>
<p><code>ROP</code> gadgets must be constructed so that when the <code>ret</code> instruction in the
instruction sequence is executed, <code>ESP</code> points to the next gadget to be
executed. The instruction sequences pointed to by gadgets must also reside
within executable segments of memory.</p>
<p>The characteristics of usable <code>JOP</code> gadgets are described in the previous
section: <a href="return-oriented-programming/aslr-nx.html#what-is-jop">&quot;What is JOP?&quot;</a></p>
<h2 id="what-kind-of-primitives-and-conditions-might-allow-you-to-bypass-aslr-via-ropjop-on-a-non-pie-binary"><a class="header" href="#what-kind-of-primitives-and-conditions-might-allow-you-to-bypass-aslr-via-ropjop-on-a-non-pie-binary">What kind of primitive(s) and condition(s) might allow you to bypass ASLR via ROP/JOP on a non-PIE binary?</a></h2>
<p>Untrusted Pointer Dereferences, Out-of-bounds Reads, Buffer Over-reads and
similar conditions that provide arbitrary or relative read primitives can be
used in a <code>ROP</code>/<code>JOP</code> attack to bypass <code>ASLR</code>. An attacker would aim to expose
a <code>libc</code> address to calculate the base of <code>libc</code> within the mapping of the
target's memory.</p>
<p>For a non-<code>PIE</code> binary, an attacker could also construct a <code>ROP</code> gadget that
would return into the <code>.plt</code> section to execute some <code>libc</code> function like
<code>printf</code> or <code>puts</code>. The target of this <code>printf</code> or <code>puts</code> call would be an
entry within <code>.got.plt</code> for a <code>libc</code> function that has already been resolved
by the linker. This would expose the address of the target <code>libc</code> function to
the attacker, allowing the attacker to calculate the base of <code>libc</code> within the
target's memory. This method works on non-<code>PIE</code> binaries because the <code>.plt</code>
section will be defined at some static address.</p>
<h2 id="can-the-plt-be-used-to-call-libc-functions-even-when-pie-is-enabled-what-primitives-and-conditions-might-be-required"><a class="header" href="#can-the-plt-be-used-to-call-libc-functions-even-when-pie-is-enabled-what-primitives-and-conditions-might-be-required">Can the PLT be used to call libc functions even when PIE is enabled? What primitive(s) and condition(s) might be required?</a></h2>
<p>With <code>PIE</code> enabled, we must find some way to expose a program address to
calculate the base of the program loaded into the process's memory. This allows
us to calculate the location of the <code>.plt</code> section of the program within
memory. The same conditions as in the previous bullet are necessary; Untrusted
Pointer Dereferences, Out-of-bounds Reads, Buffer Over-reads and similar
conditions that provide arbitrary or relative read primitives can be used to
expose sensitive information required to build an exploit.</p>
<h2 id="how-does-ropjop-evade-nxwx"><a class="header" href="#how-does-ropjop-evade-nxwx">How does ROP/JOP evade NX/W^X?</a></h2>
<p>NX, DEP, or the concept of W^X were created in order to combat conventional
code injection techniques that usually executed code directly from the stack.
Attackers found a way around this by using code that was already present within
memory and marked executable, thus inventing return-oriented programming and
jump-oriented programming.</p>
<p>A sufficient set of <code>ROP</code>/<code>JOP</code> gadgets provides Turing complete functionality
to the attacker, evading the W^X protection mechanism that is designed to
prevent arbitrary code execution.</p>
<h2 id="references-22"><a class="header" href="#references-22">References</a></h2>
<ol>
<li><a href="https://hovav.net/ucsd/dist/rop.pdf">https://hovav.net/ucsd/dist/rop.pdf</a></li>
<li><a href="http://www.cs.jhu.edu/%7Esdoshi/jhuisi650/papers/spimacs/SPIMACS_CD/stc/p49.pdf">http://www.cs.jhu.edu/~sdoshi/jhuisi650/papers/spimacs/SPIMACS_CD/stc/p49.pdf</a></li>
<li><a href="https://link.springer.com/chapter/10.1007%2F978-3-642-10772-6_13">https://link.springer.com/chapter/10.1007%2F978-3-642-10772-6_13</a></li>
<li><a href="https://www.csc2.ncsu.edu/faculty/xjiang4/pubs/ASIACCS11.pdf">https://www.csc2.ncsu.edu/faculty/xjiang4/pubs/ASIACCS11.pdf</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="finding-gadgets"><a class="header" href="#finding-gadgets">Finding gadgets</a></h1>
<h2 id="what-methods-have-been-used-to-find-ropjop-gadgets"><a class="header" href="#what-methods-have-been-used-to-find-ropjop-gadgets">What methods have been used to find ROP/JOP gadgets?</a></h2>
<p>It is known that <code>ROP</code> gadgets must end in a <code>ret</code> instruction. This allows us
to search through a target binary or shared library to find our useful
instruction sequences that will comprise our gadgets. Luckily for us, in both
the <code>x86</code> and <code>amd64</code> architectures, instructions are variable-length and
unaligned. This means that we can use both intended and unintended instruction
sequences found within our targets, increasing the collection of available
gadgets.</p>
<p>A primary method presented in Hovav Shacham's paper is to find <code>ret</code>
instructions and scan <em>backwards</em>, using an algorithm that uses each <code>ret</code>
instruction as the root node of a tree and determining if the preceding bytes
represent valid instructions. Each child node of the tree is a valid gadget,
and the algorithm recursively explores the bytes preceding each child to
determine if they are also valid gadgets that can be added to the tree - up to
the maximum length of a valid <code>x86</code> instruction.</p>
<p>Hovav contrasts this with finding <code>ROP</code> gadgets for <code>SPARC</code> targets. We cannot
use unintended instruction sequences to represent <code>ROP</code> gadgets because <code>SPARC</code>
enforces alignment on instruction read.
<a href="return-oriented-programming/finding-gadgets.html#references">[4]</a> This essentially reinforces the
point that an attacker must understand the specifics of the particular
architecture they are attacking when condcuting <code>ROP</code>.</p>
<p>Finding <code>JOP</code> gadgets follows a similar technique. A linear search can be
conducted to find the valid starting bytes for an indirect branch instruction:
<code>0xff</code>. This byte is usually followed by a second byte with a specified range
of values. In the same manner as <code>ROP</code>, a search is conducted backwards to
discover valid instructions that will comprise the gadget.</p>
<p>In Xuxian Jiang's paper, a series of algorithms are utilized to find gadgets,
deteremine if a gadget is viable for use, and to filter gadgets based upon a
set of heuristics - separating the gadgets into groups that can be used for
the <code>dispatcher gadget</code> and <code>functional gadgets</code>.
<a href="return-oriented-programming/finding-gadgets.html#references">[5]</a></p>
<h3 id="what-constraints-on-the-gadget-searching-problem-are-added-or-removed-by-searching-for-gadgets-in-risc-architectures-like-arm-or-mips-instead-of-x86amd64"><a class="header" href="#what-constraints-on-the-gadget-searching-problem-are-added-or-removed-by-searching-for-gadgets-in-risc-architectures-like-arm-or-mips-instead-of-x86amd64">What constraints on the gadget-searching problem are added or removed by searching for gadgets in RISC architectures (like ARM or MIPS) instead of x86/amd64?</a></h3>
<p>For <code>x86</code>/<code>amd64</code> architectures, instructions are variable-length and
unaligned. This means that we can consider both intentional and unintentional
instructions for <code>ROP</code> gadgets. An unintentional instruction meaning we are
jumping into the <em>middle</em> of intentional instructions.</p>
<p>In contrast, <code>SPARC</code>, <code>MIPS</code>, and <code>ARM</code> enforce word alignment for
instructions - this rules out the possibility of deriving our gadgets from
unintentional instructions.</p>
<h2 id="what-are-some-common-tools-used-to-find-ropjop-gadgets"><a class="header" href="#what-are-some-common-tools-used-to-find-ropjop-gadgets">What are some common tools used to find ROP/JOP gadgets?</a></h2>
<p>The most popular tools used to discover <code>ROP</code> gadgets are <code>ROPgadget</code> and
<code>ropper</code>. The links to these tools can be found in the
<a href="return-oriented-programming/finding-gadgets.html#references">References</a> section. <a href="return-oriented-programming/finding-gadgets.html#references">[1]</a>, <a href="return-oriented-programming/finding-gadgets.html#references">[2]</a>
The <code>pwntools</code> CTF framework and exploit development library also provides
a <code>ROP</code> module that can find <code>ROP</code> gadgets and create <code>ROP</code> chains.
<a href="return-oriented-programming/finding-gadgets.html#references">[3]</a></p>
<h3 id="how-might-you-implement-a-similar-tool-yourself-high-level-overview"><a class="header" href="#how-might-you-implement-a-similar-tool-yourself-high-level-overview">How might you implement a similar tool yourself (high-level overview)?</a></h3>
<p>A similar tool that could be implemented quickly would follow some of these
steps:</p>
<ul>
<li>User specifies the instruction to search for.</li>
<li>Dump the target binary or shared library into hex (using something like
<code>xxd</code>).</li>
<li>Use a regular expression to search for the opcode that represents <code>ret</code>:
<code>0xc3</code>.</li>
<li>Using the data returned from the results of this search, use another regular
expression to search for the opcode representing the specific instruction
requested by the user.</li>
<li>Return the line number that contains the gadget we found to the user.</li>
</ul>
<p>A quick and dirty command line method to find a gadget sequence can be found
in <a href="https://crypto.stanford.edu/%7Eblynn/rop/">this blog</a> on <code>ROP</code>.</p>
<h2 id="references-23"><a class="header" href="#references-23">References</a></h2>
<ol>
<li><a href="https://github.com/JonathanSalwan/ROPgadget">https://github.com/JonathanSalwan/ROPgadget</a></li>
<li><a href="https://github.com/sashs/Ropper">https://github.com/sashs/Ropper</a></li>
<li><a href="https://docs.pwntools.com/en/stable/rop/rop.html">https://docs.pwntools.com/en/stable/rop/rop.html</a></li>
<li><a href="https://hovav.net/ucsd/dist/rop.pdf">https://hovav.net/ucsd/dist/rop.pdf</a></li>
<li><a href="https://www.csc2.ncsu.edu/faculty/xjiang4/pubs/ASIACCS11.pdf">https://www.csc2.ncsu.edu/faculty/xjiang4/pubs/ASIACCS11.pdf</a></li>
<li><a href="https://crypto.stanford.edu/%7Eblynn/rop/">https://crypto.stanford.edu/~blynn/rop/</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-libc-functions--syscalls"><a class="header" href="#calling-libc-functions--syscalls">Calling libc functions / syscalls</a></h1>
<h2 id="calling-conventions"><a class="header" href="#calling-conventions">Calling conventions</a></h2>
<p>First, let's talk about <strong>calling conventions</strong>. For the System V <code>x86</code>
application binary interface (ABI), parameters to functions are passed on the
stack in reverse order such that the first parameter is the last value pushed
to the stack.</p>
<p>Functions are called using the <code>call</code> instruction, pushing the address of the
next instruction onto the stack and jumping to the operand. Functions return
to the caller using <code>ret</code>, popping a value from the stack and jumping to it.</p>
<p>Function calls preserve the registers <code>ebx</code>, <code>esi</code>, <code>edi</code>, <code>ebp</code>, and <code>esp</code>.
<code>eax</code>, <code>ecx</code>, and <code>edx</code> are scratch registers, their values might not be the
same after a function call. The return value of a function is stored in <code>eax</code>,
unless the return value is a 64-bit value, then the higher 32-bits will be
returned in <code>edx</code>.</p>
<p>For the System V <code>x86-64</code> ABI, parameters to functions are passed in the
registers <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, and <code>r9</code>. If a function call
requires more than 6 parameters, further values are passed to the function
call on the stack in reverse order. Functions return to the caller using <code>ret</code>,
popping a value from the stack and jumping to it.</p>
<p>Function calls preserve the registers <code>rbx</code>, <code>rsp</code>, <code>rbp</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>,
and <code>r15</code>. <code>rax</code>, <code>rdi</code>, <code>rsi</code>, <code>rdx</code>, <code>rcx</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, and <code>r11</code> are
scratch registers, their values might not be the same after a function call.
The return value of a function is stored in <code>rax</code>, unless the return value is a
128-bit value, then the higher 64-bits will be returned in <code>rdx</code>.
<a href="return-oriented-programming/calling-libc-functions-and-syscalls.html#references">[1]</a></p>
<h2 id="the-standard-c-library-and-syscalls"><a class="header" href="#the-standard-c-library-and-syscalls">The standard C library and syscalls</a></h2>
<p><strong>What's a <code>libc</code> function?</strong></p>
<p>The term <code>libc</code> is shorthand for the &quot;standard C library&quot;. The most widely used
C library on Linux is the <a href="http://www.gnu.org/software/libc/">GNU C Library</a>,
referred to as <code>glibc</code>. The pathname for your installation of <code>libc</code> on a
Linux operating system is probably something similar to: <code>/lib/libc.so.6</code>. For
a dynamically-linked target binary, you can use <code>ldd</code> to print its shared
object dependencies - you'll usually find <code>libc.so.6</code> there.
<a href="return-oriented-programming/calling-libc-functions-and-syscalls.html#references">[2]</a></p>
<p><code>libc</code> functions are functions exported by the <code>libc.so.6</code> shared library.
<code>libc</code> functions are commonly used functions within the C programming
language, for example: <code>printf()</code>, <code>puts()</code>, <code>gets()</code></p>
<p><strong>What's a <code>syscall</code>?</strong></p>
<p>A system call (<code>syscall</code>), sometimes called kernel calls, is a request for
service that a program makes of the kernel. This is usually a privileged
operation, like changing permissions of a file, opening a file descriptor, etc.
The <code>libc</code> functions mentioned earlier usually handle <code>syscall</code>s for the
programmer, however, an attacker sometimes has to make <code>syscall</code>s directly for
an exploit to work. <a href="return-oriented-programming/calling-libc-functions-and-syscalls.html#references">[3]</a></p>
<p>To make a <code>syscall</code> directly on <code>x86</code> on a Linux operating system, first
ensure your registers contain their necessary values.
<a href="return-oriented-programming/calling-libc-functions-and-syscalls.html#references">[4]</a> Then, issue the instruction <code>int 0x80</code>. This instruction is
an interrupt that passes control to interrupt vector <code>0x80</code>. On Linux, this
interrupt vector is used to handle <code>syscall</code>s. <a href="return-oriented-programming/calling-libc-functions-and-syscalls.html#references">[5]</a></p>
<p>To make a <code>syscall</code> directly on <code>x86-64</code> on a Linux operating system, first
ensure your registers contain their necessary values.
<a href="return-oriented-programming/calling-libc-functions-and-syscalls.html#references">[6]</a> Then, issue the instruction <code>syscall</code>. <a href="return-oriented-programming/calling-libc-functions-and-syscalls.html#references">[7]</a></p>
<h2 id="using-rop-to-call-a-libc-function"><a class="header" href="#using-rop-to-call-a-libc-function">Using ROP to call a libc function</a></h2>
<p>Now that we understand the calling conventions, we can use ROP to call <code>libc</code>
functions. We're going to assume that the attacker already has control over the
<code>stack</code> and the <code>EIP</code> or <code>RIP</code>. We're also going to assume that the attacker
has used an information leak to expose sensitive information, namely the base
of <code>libc</code> within memory. With these conditions, the attacker can execute one of
the most basic ROP attacks: <code>ret2libc</code>.</p>
<p>The attacker must use their control over the <code>EIP</code>/<code>RIP</code> and <code>stack</code> to
construct a stack frame that will call <code>libc</code>'s <code>system()</code> function. The
attacker will also craft the stack frame so that the <code>system()</code> function will
use the string <code>'/bin/sh'</code> as an argument.</p>
<p>Here's what the stack would look like for a <code>ret2libc</code> attack on <code>x86</code>:</p>
<pre><code class="language-python">p32(system)         # Address of system() function within libc
p32(0xcafebabe)     # Fake return pointer
p32(bin_sh_ptr)     # arg0: pointer to '/bin/sh' string
</code></pre>
<p>After the <code>stack</code> is corrupted with the attacker's <code>ret2libc</code> <code>stack</code> frame,
when the vulnerable function conducts a <code>ret</code>, the program will <code>pop</code> the
<code>system()</code> address from the <code>stack</code> and jump to <code>system()</code> within <code>libc</code>. The
<code>system()</code> function will continue execution and use the pointer to the
<code>'/bin/sh'</code> string as an argument, executing <code>system('/bin/sh')</code>.</p>
<p>For <code>x86-64</code>, remember that we need to place our arguments into registers
before making calls to <code>libc</code> functions. A <code>ret2libc</code> attack will look slightly
different:</p>
<pre><code class="language-python">p64(pop_rdi_ret)    # pop rdi; ret gadget
p64(bin_sh_ptr)     # arg0: pointer to '/bin/sh' string
p64(system)         # Address of system() function within libc
</code></pre>
<p>For <code>x86-64</code>, <code>system()</code> expects <code>arg0</code> to be contained within the <code>rdi</code>
register. Using our techniques discussed earlier to find <code>ROP</code> gadgets, we
find a <code>pop rdi; ret</code> gadget within either <code>libc</code> or the target binary. We use
this gadget to <code>pop</code> the address of our <code>'/bin/sh'</code> string into <code>rdi</code> and then
we <code>ret</code> into the address of <code>system()</code>. Just like in <code>x86</code>, this executes
<code>system('/bin/sh')</code>.</p>
<p><strong>The next section will cover executing <code>syscall</code>s directly.</strong></p>
<h2 id="references-24"><a class="header" href="#references-24">References</a></h2>
<ol>
<li><a href="https://wiki.osdev.org/System_V_ABI">https://wiki.osdev.org/System_V_ABI</a></li>
<li><a href="https://man7.org/linux/man-pages//man7/libc.7.html">https://man7.org/linux/man-pages//man7/libc.7.html</a></li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/System-Calls.html">https://www.gnu.org/software/libc/manual/html_node/System-Calls.html</a></li>
<li><a href="https://web.archive.org/web/20200218024630/https://syscalls.kernelgrok.com/">https://web.archive.org/web/20200218024630/https://syscalls.kernelgrok.com/</a></li>
<li><a href="https://en.wikipedia.org/wiki/Interrupt_vector_table">https://en.wikipedia.org/wiki/Interrupt_vector_table</a></li>
<li><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/">https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a></li>
<li><a href="https://www.cs.fsu.edu/%7Elangley/CNT5605/2017-Summer/assembly-example/assembly.html">https://www.cs.fsu.edu/~langley/CNT5605/2017-Summer/assembly-example/assembly.html</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chaining-gadgets-to-execute-code"><a class="header" href="#chaining-gadgets-to-execute-code">Chaining gadgets to execute code</a></h1>
<h2 id="creating-a-rop-chain-on-x86"><a class="header" href="#creating-a-rop-chain-on-x86">Creating a ROP chain on x86</a></h2>
<p>Cool, so now we know how to call one <code>libc</code> function, let's call multiple.
Let's assume I have a file I want to read the contents of and the name of the
file is already within memory. I have full control of the <code>stack</code> and the
<code>EIP</code>/<code>RIP</code>. We crafted a <code>stack</code> frame to call <code>system()</code> with the argument
<code>'/bin/sh'</code> in the previous section. How do we craft a <code>stack</code> frame that calls
<code>open()</code> to open a file descriptor with our target file, <code>read()</code> to read the
data within the file into memory, and then <code>write()</code> to write the data to
<code>stdout</code>?</p>
<p>Again, we assume that the attacker has used an information leak to expose
sensitive information allowing them to discover the base of <code>libc</code> in memory.
The attacker also knows the location of the <code>filename_ptr</code> in memory.</p>
<p>Here's an example stack frame to accomplish this in <code>x86</code>:</p>
<pre><code class="language-python">p32(open_sym)           # address of open() function within libc
p32(pop_pop_pop_ret)    # pop %; pop %; pop %; ret gadget
p32(filename_ptr)       # arg0: pointer to filename string
p32(0x0)                # arg1: O_RDONLY
p32(0x0)                # arg2: 0 for mode
p32(read_sym)           # address of read() function within libc
p32(pop_pop_pop_ret)    # pop %; pop %; pop %; ret gadget
p32(0x3)                # arg0: assume fd of the target is 3
p32(initial)            # arg1: initial data structure in libc (rw-)
p32(1024)               # arg2: num of bytes to read from fd 3
p32(write_sym)          # address of write() function within libc
p32(pop_pop_pop_ret)    # pop %; pop %; pop %; ret gadget
p32(0x1)                # arg0: fd 1 (stdout)
p32(initial)            # arg1: initial data structure with our file content
p32(1024)               # arg2: num of bytes to write to fd 1 (stdout)
p32(exit_sym)           # address of exit() function within libc
</code></pre>
<p><strong>So what's happening in this stack frame?</strong></p>
<p>When the attacker overwrites the stack frame of the vulnerable function with
the code in this example, the vulnerable function will <code>ret</code> into our first
function call: <code>open()</code>. <code>open()</code> is going to use the <code>filename_ptr</code> for its
first argument (<code>const char *pathname</code>), <code>0x0</code> (<code>O_RDONLY</code>) for its second
argument (<code>int flags</code>), and <code>0x0</code> for its third argument (<code>mode_t mode</code>).</p>
<p>If the <code>open()</code> function is successful, <code>eax</code> will contain the file descriptor
of the now open file pointed to by <code>filename_ptr</code> - in this example we're
assuming the file descriptor is <code>3</code>. Next, we use a <code>pop %; pop %; pop %; ret</code>
gadget to <code>pop</code> our arguments to <code>open()</code> off of the stack. The operand for
these <code>pop %</code> instructions doesn't really matter, so long as it's not <code>ESP</code>.</p>
<p>The <code>pop %; pop %; pop %; ret</code> gadget will now <code>ret</code> into our <code>read()</code> address
on the <code>stack</code>, <code>pop</code>ing the word off of the <code>stack</code> and executing <code>libc</code>'s
<code>read()</code> function. <code>read()</code> is going to use <code>0x3</code> for its first argument
(<code>int fd</code>), <code>initial</code> for its second argument (<code>void* buf</code>), and <code>1024</code> for
its third argument (<code>size_t count</code>). If the <code>read()</code> function is successful,
<code>eax</code> will contain the number of bytes read from the file. We <code>ret</code> into our
gadget to <code>pop</code> all of <code>read()</code>'s arguments off the <code>stack</code>, then we <code>ret</code>
into our <code>write()</code> call.</p>
<p><code>write()</code> is going to use <code>0x1</code> (<code>stdout</code>) for its first argument (<code>int fd</code>),
<code>initial</code> for its second argument (<code>const void *buf</code>), and <code>1024</code> for its third
argument (<code>size_t count</code>). If the <code>write()</code> function is successful, <code>eax</code> will
contain the number of bytes that was written to <code>stdout</code>. We <code>ret</code> into our
gadget and <code>pop</code> all of <code>write</code>'s arguments off the <code>stack</code>, then we <code>ret</code> into
our <code>exit()</code> call.</p>
<h3 id="can-you-explain-in-greater-detail-why-pop--pop--ret-esque-gadgets-are-needed-for-building-rop-chains-on-x86"><a class="header" href="#can-you-explain-in-greater-detail-why-pop--pop--ret-esque-gadgets-are-needed-for-building-rop-chains-on-x86">Can you explain in greater detail why <code>pop %; pop %; ret</code>-esque gadgets are needed for building ROP chains on x86?</a></h3>
<p>If we didn't use a <code>pop %; pop %; pop %; ret</code> gadget to clear our function
arguments off of the <code>stack</code>, the <code>stack</code> frame would look something like this:</p>
<pre><code class="language-python">p32(open_sym)
p32(read_sym)
p32(filename_ptr)
p32(0x0)
p32(0x0)
</code></pre>
<p><strong>So what's the problem here?</strong></p>
<p>When <code>open()</code> finishes, we'll <code>ret</code> into our <code>read()</code> call. This isn't going
to work out well for us though because <code>read()</code>'s arguments don't make any
sense now. Our first argument for <code>read()</code> points to a <code>null</code> byte, which isn't
a <code>filename_ptr</code>.</p>
<p>It's necessary for us to use <code>pop %; pop %; pop %; ret</code> gadgets in order to
clear the previous function call's arguments from the stack. These gadgets
allow us to effectively chain multiple function calls. <a href="return-oriented-programming/chaining-gadgets-to-execute-code.html#references">[1]</a></p>
<h2 id="creating-a-rop-chain-on-x86-64"><a class="header" href="#creating-a-rop-chain-on-x86-64">Creating a ROP chain on x86-64</a></h2>
<p>Let's do the same <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>exit()</code> <code>ROP</code> chain on
<code>x86-64</code>:</p>
<pre><code class="language-python">p64(pop_rdi_ret)            # load filename_ptr into rdi
p64(filename_ptr)           # arg0: pointer to filename string
p64(pop_rsi_pop_r15_ret)    # load flags into rsi
p64(0x0)                    # arg1: O_RDONLY
p64(0xcafebabe)             # dummy bytes loaded into r15
p64(pop_rdx_ret)            # load mode into rdx
p64(0x0)                    # arg2: 0 for mode
p64(open_sym)               # address of open() function within libc
p64(pop_rdi_ret)            # load fd into rdi
p64(0x3)                    # arg0: assume fd of the target is 3
p64(pop_rsi_pop_r15_ret)    # load initial into rsi
p64(initial)                # arg1: initial data structure in libc (rw-)
p64(0xcafebabe)             # dummy bytes loaded into r15
p64(pop_rdx_ret)            # load num of bytes to read into rdx
p64(1024)                   # arg2: num of bytes to read from fd 3
p64(read_sym)               # address of read() function within libc
p64(pop_rdi_ret)            # load fd 1 (stdout) into rdi
p64(0x1)                    # arg0: fd 1(stdout)
p64(pop_rsi_pop_r15_ret)    # load initial into rsi
p64(initial)                # arg1: initial data structure with file content
p64(0xcafebabe)             # dummy bytes loaded into r15
p64(pop_rdx_ret)            # load num of bytes to write into rdx
p64(1024)                   # arg2: num of bytes to write to fd 1 (stdout)
p64(write_sym)              # address of write() function within libc
p64(exit_sym)               # address of exit() function within libc
</code></pre>
<p><strong>So what's happening in this stack frame?</strong></p>
<p>The operations that take place within this <code>stack</code> frame are exactly the same
as what took place in the <code>x86</code> example, we're just using <code>ROP</code> gadgets to
ensure that we're following the <code>x86-64</code> calling convention. Each <code>pop %; ret</code>
gadget is <code>pop</code>ing our arguments from the <code>stack</code> into the correct registers
for each <code>libc</code> function call. You can see that not everything is perfect,
though. The <code>pop rsi; pop r15; ret</code> gadget is <code>pop</code>ing a dummy value from the
<code>stack</code> into <code>r15</code>. We're not always going to find the perfect gadget to
<code>pop %</code> just one value into our target register - we have to make due with
what's available.</p>
<h2 id="creating-a-rop-chain-to-execute-syscalls-on-x86-and-x86-64"><a class="header" href="#creating-a-rop-chain-to-execute-syscalls-on-x86-and-x86-64">Creating a ROP chain to execute syscalls on x86 and x86-64</a></h2>
<p>Alright, so now that we understand how to chain gadgets to make multiple <code>libc</code>
calls, here are some examples of <code>ROP</code> chains that execute <code>syscall</code>s in <code>x86</code>
and <code>x86-64</code>.</p>
<p>Here's an example <code>ROP</code> chain that executes
<code>sys_open(filename_ptr, O_RDONLY, 0)</code> in <code>x86</code>:</p>
<pre><code class="language-python">p32(pop_ebx_ret)    # load filename_ptr into ebx
p32(filename_ptr)   # arg0: pointer to filename string
p32(pop_ecx_ret)    # load flags into ecx
p32(0x0)            # arg1: O_RDONLY 
p32(pop_edx_ret)    # load mode into edx
p32(0x0)            # arg2: 0 for mode
p32(pop_eax_ret)    # load syscall number into eax
p32(0x5)            # syscall number for sys_open
p32(int_80_ret)     # int 0x80; ret gadget
</code></pre>
<p>Here's an example <code>ROP</code> chain that executes
<code>sys_open(filename_ptr, O_RDONLY, 0)</code> in <code>x86-64</code>:</p>
<pre><code class="language-python">p64(pop_rdi_ret)    # load filename_ptr into rdi
p64(filename_ptr)   # arg0: pointer to filename string
p64(pop_rsi_ret)    # load flags into rsi
p64(0x0)            # arg1: O_RDONLY 
p64(pop_rdx_ret)    # load mode into rdx
p32(0x0)            # arg2: 0 for mode
p32(pop_rax_ret)    # load syscall number into rax
p64(0x2)            # syscall number for sys_open
p64(syscall)        # syscall; ret
</code></pre>
<p>As you've probably noticed these two <code>ROP</code> chains seem super simple and super
similiar, but it won't always be that way. As I said earlier, creating a <code>ROP</code>
chain is a test of creativity, and you won't always be able to load your
registers with simple <code>pop %; ret</code> gadgets.</p>
<h3 id="how-might-one-combine-multiple-gadgets-into-one-register-populating-pseudo-gadget-what-are-some-useful-non-pop-instructions-for-doing-this-in-amd64"><a class="header" href="#how-might-one-combine-multiple-gadgets-into-one-register-populating-pseudo-gadget-what-are-some-useful-non-pop-instructions-for-doing-this-in-amd64">How might one combine multiple gadgets into one register-populating pseudo-gadget? What are some useful non-pop instructions for doing this in amd64?</a></h3>
<p>You can definitely find gadgets that will <code>pop</code> all of your necessary arguments
into their respective registers. If we found something like:
<code>pop rdi; pop rsi; pop rdx; ret</code> in code, we could use this gadget before
making our <code>read()</code>, <code>write()</code>, and <code>open()</code> calls. <a href="return-oriented-programming/chaining-gadgets-to-execute-code.html#references">[2]</a></p>
<p>In <code>x86</code>, there's an interesting instruction called <code>popa</code>/<code>popad</code> that <code>pop</code>s
data into all general-purpose registers. This is definitely useful if you need
to intialize all of your registers prior to executing further code.
<a href="return-oriented-programming/chaining-gadgets-to-execute-code.html#references">[3]</a></p>
<p><strong>So what if I can't find a pop instruction for my target register?</strong></p>
<p>If you can't find a <code>pop</code> instruction to directly load a register, you still
might have some options if you use <code>xor</code> and <code>xchg</code>.</p>
<p>The concept in using <code>xor</code> to load a register is as follows <a href="return-oriented-programming/chaining-gadgets-to-execute-code.html#references">[2]</a>:</p>
<ol>
<li><code>xor</code> your target register against itself to zero it out.</li>
<li><code>pop</code> the data you want to load into a different register.</li>
<li><code>xor</code> your target register against the other register, duplicating the data
into your target register.</li>
</ol>
<p>The concept in using <code>xchg</code> to load a register is as follows
<a href="return-oriented-programming/chaining-gadgets-to-execute-code.html#references">[2]</a>:</p>
<ol>
<li><code>pop</code> the data you want to load into a different register.</li>
<li>execute an <code>xchg</code> with your target register and the register containing your
data.</li>
</ol>
<p><strong>Using the <code>xchg</code> method will swap the data between the two registers. Ensure
you reload the register you used to execute <code>xchg</code> if you intend to use it
later.</strong></p>
<p>The <code>mov %, %; ret</code> gadget is also a viable method to load target registers.
Generating <code>ROP</code> chains to create exploits is just a test of the exploiter's
creativity.</p>
<h2 id="under-what-conditions-would-one-need-to-stack-pivot-what-are-some-locations-an-attacker-could-store-a-second-stage-chain-for-use-in-a-stack-pivot"><a class="header" href="#under-what-conditions-would-one-need-to-stack-pivot-what-are-some-locations-an-attacker-could-store-a-second-stage-chain-for-use-in-a-stack-pivot">Under what conditions would one need to stack pivot? What are some locations an attacker could store a second-stage chain for use in a stack pivot?</a></h2>
<p>These <code>ROP</code> chains can get pretty long, sometimes we might not be able to write
more than a handful of words to the <code>stack</code>. In these conditions, we'll have to
conduct a <code>stack</code> pivot.</p>
<p>A <code>stack</code> pivot is a technique that relocates the <code>stack</code> to some other
location in memory. This allows us to completely control the contents of the
<code>stack</code>, and this is where we can place more words for our <code>ROP</code> chain. When
we pivot the <code>stack</code> to our new location, we can continue executing our <code>ROP</code>
chain without any of the pesky restrictions we faced on the original <code>stack</code>.</p>
<p>In order to pivot the <code>stack</code>, we <code>pop</code> the location containing the rest of
our <code>ROP</code> chain into the <code>ESP</code>/<code>RSP</code> register. Then, when our <code>pop rsp; ret</code>
gadget executes <code>ret</code>, the <code>stack</code> will be pointing to the location in memory
containing our second stage <code>ROP</code> chain.</p>
<p>An attacker could place a second stage <code>ROP</code> chain in any know read/writeable
location in memory. These locations could include the <code>heap</code>, the <code>stack</code>, a
buffer in <code>.bss</code> or <code>.data</code>, or (my personal favorite) <code>libc</code>'s <code>initial</code> data
structure. <a href="return-oriented-programming/chaining-gadgets-to-execute-code.html#references">[2]</a></p>
<h3 id="im-not-familiar-with-the-initial-libc-structure-can-you-explain-what-it-is"><a class="header" href="#im-not-familiar-with-the-initial-libc-structure-can-you-explain-what-it-is">I'm not familiar with the initial libc structure, can you explain what it is?</a></h3>
<p><code>initial</code> is a data section within <code>libc</code> that is read/writeable. If you know
the base of <code>libc</code> within memory and you know the version of <code>libc</code> being used
by a target program, you can determine the location of <code>libc</code>'s <code>initial</code> data
structure within memory. It's a useful location to store file data that's been
read into memory, or second-stage <code>ROP</code> chains because the data strucuture is
usually empty.</p>
<p>The <code>initial</code> data structure is used by the <code>libc</code> function <code>atexit()</code> to store
a list of function pointers that will be called when <code>exit()</code> is called. In the
<code>Left</code> challenge from <strong>0x00 CTF 2017</strong>, the <code>initial</code> data structure plays a
role in gaining control of the <code>RIP</code>.</p>
<p>Function pointers within <code>initial</code> are <code>xor</code>d with some secret in thread-local
storage (TLS) and then rotated left 17 bits. In the <code>Left</code> challenge the
attacker needs to expose an entry within <code>initial</code>, derive the secret from the
entry, and then replace the entry in <code>initial</code> with a <code>one_gadget</code>. Then, when
<code>exit()</code> is called, the <code>one_gadget</code> is executed. This technique was
necessary because the target program had <code>Full RELRO</code> protections enabled,
preventing the attacker from overwriting a <code>.got.plt</code> entry.
<a href="return-oriented-programming/chaining-gadgets-to-execute-code.html#references">[4]</a></p>
<p>All that being said, yes if you know the location of <code>.data</code> or <code>.bss</code> within
the program it's just as easy to write your second-stage <code>ROP</code> chain there.
However, if the program has the <code>PIE</code> protection mechanism enabled and you
don't feel like deriving the base of the program within memory, <code>initial</code> is
another read/writeable location that can be easily derived from the base of
<code>libc</code>. Use this location at your own discretion though, especially if some
information contained with <code>initial</code> seems important.</p>
<h3 id="references-25"><a class="header" href="#references-25">References</a></h3>
<ol>
<li><a href="https://hovav.net/ucsd/dist/blackhat08.pdf">https://hovav.net/ucsd/dist/blackhat08.pdf</a></li>
<li><a href="https://trustfoundry.net/basic-rop-techniques-and-tricks/">https://trustfoundry.net/basic-rop-techniques-and-tricks/</a></li>
<li><a href="http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc246.htm">http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc246.htm</a></li>
<li><a href="https://github.com/SPRITZ-Research-Group/ctf-writeups/tree/master/0x00ctf-2017/pwn/left-250">https://github.com/SPRITZ-Research-Group/ctf-writeups/tree/master/0x00ctf-2017/pwn/left-250</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="executing-arbitrary-shellcode"><a class="header" href="#executing-arbitrary-shellcode">Executing arbitrary shellcode</a></h1>
<p>At this point, we've covered how to use <code>ROP</code> to call a <code>libc</code> function, how to
chain together multiple <code>ROP</code> gadgets to call <code>libc</code> functions in succession,
and how to create <code>ROP</code> chains that execute <code>syscall</code>s directly. What if we
wanted to execute code that wasn't already present in memory?</p>
<p>Remember, the NX/DEP/W^X protection mechanisms were created to combat code
injection techniques that usually executed code directly from the <code>stack</code>.
If we debug any normal program today with <code>gdb</code> enhancements like <code>GEF</code>,
<code>PEDA</code>, or <code>pwndbg</code>, we can inspect the process's virtual memory mapping with
<code>vmmap</code> and see the permissions for each page of memory. Notice that no pages
simultaneously have write and execute permissions. The W^X protection
mechanism tries to delineate between what can be considered &quot;code&quot; and what
can be considered &quot;data&quot;, but we see how well that works out when <code>ROP</code> is
introduced.</p>
<p><strong>How do we modify these permissions so that we can execute shellcode?</strong></p>
<p>We do what the operating system does when it sets permissions for the pages of
our process. If we inspect any program with <code>strace</code> we'll find that the
operating system makes multiple calls to the functions <code>mmap()</code> and
<code>mprotect()</code>. These two functions are used to map files or devices into memory
and to set protections on regions of memory within a process. Now that we fully
understand how to chain successive <code>libc</code> function calls, we can create a <code>ROP</code>
chain that uses <code>mprotect()</code> to modify the permissions of a known location
within memory. <a href="return-oriented-programming/executing-arbitrary-shellcode.html#references">[1]</a> In order to execute our shellcode, we would
need to follow these steps:</p>
<ol>
<li>Place our shellcode into some known, writeable location within memory.</li>
<li>Make a call to <code>mprotect()</code> to change the permissions of the page where our
shellcode resides to <code>r-xp</code>.
<ul>
<li><code>r</code> stands for <code>read</code></li>
<li><code>x</code> stands for <code>execute</code></li>
<li><code>p</code> stands for <code>private</code></li>
</ul>
</li>
<li>Return to the location in memory containing our shellcode and begin
execution.</li>
</ol>
<p>Here's an example of how we would do this in <code>x86-64</code> using <code>ROP</code>. Assume that
the attacker has used an information leak to expose sensitive information
allowing them to discover the base of <code>libc</code> in memory:</p>
<pre><code class="language-python">shellcode = asm(shellcode)          # assemble our shellcode

payload = [
    pop_rdi_pop_rsi_pop_rdx_ret,    # rdi=stdin; rsi=initial, rdx=num_bytes
    0,                              # fd 0 (stdin)
    initial,                        # libc initial data structure
    len(shellcode),                 # length of assembled shellcode
    read_sym,                       # read shellcode into initial from stdin
    pop_rdi_pop_rsi_pop_rdx_ret,    # rdi=initial, rsi=page_size, rdx=perms
    initial,                        # initial now contains our shellcode
    4096,                           # assume page size is 0x1000
    5,                              # PROT_READ|PROT_EXEC
    mprotect_sym,                   # change permissions of initial
    initial                         # ret into our shellcode
]

io.sendline(flat(payload))          # flat() ensures 8 byte alignment
io.send(shellcode)                  # write shellcode into initial with stdin
</code></pre>
<p><strong>What's happening here?</strong></p>
<p>First, we assemble our shellcode - let's assume it's a simple
<code>sys_execve('/bin/sh', NULL, NULL)</code> command. Then we construct a <code>ROP</code> chain
that will execute <code>read(STDIN, initial, len(shellcode))</code>,
<code>mprotect(initial, 4096, PROT_READ|PROT_EXEC)</code> <a href="return-oriented-programming/executing-arbitrary-shellcode.html#references">[2]</a>, and then
<code>ret</code> into our shellcode in <code>initial</code>. Finally, we send the <code>ROP</code> chain to the
target and then send the shellcode which will be <code>read()</code> into <code>initial</code> via
<code>stdin</code>.</p>
<p>Once the <code>read()</code> operation completes, <code>mprotect()</code> will change <code>initial</code> from
<code>rw-p</code> to <code>r-xp</code>, making our shellcode executable. We'll <code>ret</code> into <code>initial</code>
and begin executing our shellcode.</p>
<p><strong>How would we do this with mmap?</strong></p>
<ol>
<li>Create a file containing our shellcode.</li>
<li><code>open()</code> the file to acquire a file descriptor.</li>
<li>Make a call to <code>mmap()</code> using the new file descriptor, mapping the contents
of the shellcode into memory with the permissions <code>PROT_READ|PROT_EXEC</code> and the
flags <code>MAP_PRIVATE|MAP_ANON</code>. <a href="return-oriented-programming/executing-arbitrary-shellcode.html#references">[3]</a></li>
<li>Return to the location of the newly mapped memory containing our shellcode
and begin execution.</li>
</ol>
<p><strong>How would we do this with mmap without creating a file?</strong></p>
<ol>
<li>Make a call to <code>mmap()</code> with the permissions
<code>PROT_READ|PROT_WRITE|PROT_EXEC</code> and the flags <code>MAP_PRIVATE|MAP_ANON</code> to create
<code>rwxp</code> page(s) in memory. Use other write primitives or gadgets to write
shellcode into the newly mapped <code>rwxp</code> memory (via an open socket or <code>stdin</code>).</li>
<li>Return into the <code>rwxp</code> memory containing our shellcode and begin execution.</li>
</ol>
<p><strong>What if I don't have gadgets to retrieve the address returned from mmap?</strong></p>
<p>We use <code>mmap()</code>'s <code>MAP_FIXED</code> flag in tandem with <code>MAP_PRIVATE|MAP_ANON</code> to
control the page-aligned address used by <code>mmap()</code>. Then we can hardcode this
known address for use elsewhere in our chain for our eventual jump to our
shellcode.</p>
<h2 id="what-constraints-must-we-consider-when-attempting-to-change-the-permissions-of-existing-memory-segments-with-mprotect"><a class="header" href="#what-constraints-must-we-consider-when-attempting-to-change-the-permissions-of-existing-memory-segments-with-mprotect">What constraints must we consider when attempting to change the permissions of existing memory segments with mprotect?</a></h2>
<p>When using <code>mprotect()</code>, the location we provide for the <code>void *addr</code> argument
must be aligned to a page boundary. The same goes for <code>mmap()</code>, if the
<code>void *addr</code> argument provided is not page aligned, an error will occur. The
<code>void *addr</code> argument for <code>mmap()</code> can be <code>null</code> and this is usually the
best case - the kernel will pick a location within memory for us and the
<code>mmap()</code> call will return the address in <code>rax</code>.</p>
<h2 id="what-are-some-examplesscenarios-in-which-a-program-might-organically-contain-rwx-buffers"><a class="header" href="#what-are-some-examplesscenarios-in-which-a-program-might-organically-contain-rwx-buffers">What are some examples/scenarios in which a program might organically contain RWX buffers?</a></h2>
<p>A simple example would be a program that has NX/DEP protection mechanisms
disabled. We won't come across these types of targets too often, but there are
still some devices in the wild (like IoT devices, routers, etc.) that are
running programs without these exploit mitigation measures. For example, MIPS
Linux didn't support a non-executable stack until around 2015, which can be
considered pretty recent. <a href="return-oriented-programming/executing-arbitrary-shellcode.html#references">[4]</a><a href="return-oriented-programming/executing-arbitrary-shellcode.html#references">[5]</a></p>
<p>Another example is Just-in-Time (JIT) compilation. JIT compilation can be
summed up as a program creating new executable code that wasn't part of the
original program and then running that code. <a href="return-oriented-programming/executing-arbitrary-shellcode.html#references">[6]</a> JIT compilation
is supported in most browser applications and sometimes the memory pages that
are created to store and execute the JIT compiled code have <code>rwx</code> permissions,
allowing attackers to take advantage of these memory pages to execute arbitrary
code. This type of vulnerability was present in WebKit's JavaScriptCore library
used by the Safari web browser on Apple iOS. <a href="return-oriented-programming/executing-arbitrary-shellcode.html#references">[7]</a></p>
<p><a href="https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/">This</a> example from
the <code>oob-v8</code> challenge in *<strong>CTF 2019</strong> showcases the usage of WebAssembly to
create a <code>rwx</code> page within Google Chrome's JavaScript engine, <code>v8</code>. The author
demonstrates leaking the address of the <code>rwx</code> page using a vulnerability
discovered in <code>d8</code>, <code>v8</code>'s accompanying JavaScript read-eval-print-loop (REPL)
shell, and then using the same vulnerability to write shellcode into the
discovered memory page to gain code execution.</p>
<h3 id="references-26"><a class="header" href="#references-26">References</a></h3>
<ol>
<li><a href="https://www.ret2rop.com/2018/08/make-stack-executable-again.html">https://www.ret2rop.com/2018/08/make-stack-executable-again.html</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/mprotect.2.html">https://man7.org/linux/man-pages/man2/mprotect.2.html</a></li>
<li><a href="https://man7.org/linux/man-pages/man2/mmap.2.html">https://man7.org/linux/man-pages/man2/mmap.2.html</a></li>
<li><a href="https://lwn.net/Articles/653708/">https://lwn.net/Articles/653708/</a></li>
<li><a href="https://lore.kernel.org/patchwork/patch/506101/">https://lore.kernel.org/patchwork/patch/506101/</a></li>
<li><a href="https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction">https://eli.thegreenplace.net/2013/11/05/how-to-jit-an-introduction</a></li>
<li><a href="https://info.lookout.com/rs/051-ESQ-475/images/pegasus-exploits-technical-details.pdf">https://info.lookout.com/rs/051-ESQ-475/images/pegasus-exploits-technical-details.pdf</a></li>
<li><a href="https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/">https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploit-mitigations"><a class="header" href="#exploit-mitigations">Exploit mitigations</a></h1>
<p>In this section, you'll find my notes on exploit mitigations and how they affect
exploit development. This section includes discussions on the following topics:</p>
<ul>
<li>ASLR</li>
<li>Data Execution Prevention (DEP)/NX</li>
<li>Position Independent Executables (PIEs)</li>
<li>Stack canaries</li>
<li>Safe list unlinking</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="address-space-layout-randomization-aslr"><a class="header" href="#address-space-layout-randomization-aslr">Address Space Layout Randomization (ASLR)</a></h1>
<h2 id="a-history-lesson"><a class="header" href="#a-history-lesson">A history lesson</a></h2>
<p>Before we describe what ASLR is or how it's used to prevent exploitation, we
need to understand why it was created.</p>
<p>In 1996, a hacker by the name of <strong>Aleph One</strong> published an article in
<strong>Phrack Magazine</strong> titled, &quot;<em>Smashing the Stack for Fun and Profit</em>&quot;. In this
article, Aleph One describes, in great detail, how buffer overflow
vulnerabilities can be exploited to gain arbitrary code execution. These
exploitation techniques utilized a stack buffer overflow to overwrite the saved
return pointer of a function with a stack address. When the vulnerable function
executes its final <code>ret</code> instruction, the process jumps into the stack and
begins to execute whatever data is residing at the provided location in the
stack - the data being the attacker's shellcode. <a href="exploit-mitigations/aslr.html#references">[1]</a></p>
<p>The hacker, <strong>Solar Designer</strong>, took this a step further by introducting the
<code>ret2libc</code> technique. <code>ret2libc</code> leverages a stack buffer overflow to gain
control of a function's saved return address, however, instead of <code>ret</code>urning
into the stack, the process <code>ret</code>urns into <code>libc</code>'s <code>system()</code> symbol. The
attacker crafts the stack frame so that <code>system()</code> interprets the string
<code>'/bin/sh'</code> as its first argument, hijacking the process to call
<code>system('/bin/sh')</code>. <a href="exploit-mitigations/aslr.html#references">[2]</a></p>
<p>In order to thwart these stack buffer overflow exploitation techniques, the
<strong>PaX Team</strong> released <strong>PaX</strong>, a patch for the Linux kernel that implements the
<code>W^X</code> protection for memory pages and ASLR. <a href="exploit-mitigations/aslr.html#references">[3]</a> In a future
section we'll cover the concept of <code>W^X</code> and the non-executable stack.</p>
<h2 id="so-what-is-aslr"><a class="header" href="#so-what-is-aslr">So what is ASLR?</a></h2>
<p>&quot;<em>The goal of Address Space Layout Randomization is to introduce randomness
into addresses used by a given task. This will make a class of exploit
techniques fail with a quantifiable probability and also allow their detection
since failed attempts will most likely crash the attacked task.</em>&quot; - The PaX
Team <a href="exploit-mitigations/aslr.html#references">[4]</a></p>
<p>The exploit techniques of the past relied upon the memory image of the process
being exploited to be the same for each exploit, with minor differences due
to changes in the environment. Attackers could expect that the <code>libc</code>
<code>system()</code> symbol and a <code>'/bin/sh'</code> string would be at static locations within
memory for each exploit. ASLR randomizes the base addresses of the heap, shared
objects, and the stack when these segments are mapped into process memory,
attempting to introduce enough entropy to prevent an attacker from successfully
brute forcing their locations. Without knowledge of the base address of <code>libc</code>
within a target's memory, attackers conducting the <code>ret2libc</code> exploit
technique have to guess the <code>system()</code> symbol address and the <code>'/bin/sh'</code>
string's address.</p>
<h2 id="aslr-in-action"><a class="header" href="#aslr-in-action">ASLR in action</a></h2>
<p>To see ASLR for yourself, first let's turn it off. This technique works on
Ubuntu 18.04 - if it doesn't seem to work for you, try looking up how your
operating system implements ASLR and how you can enable/disable it. To turn off
ASLR globally for all processes, execute the following command:</p>
<pre><code class="language-bash">echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
</code></pre>
<p>Now, lets see how this affects the mappings of our processes. Run <code>strace</code> on
<code>/bin/ls</code> and notice the results of the <code>mmap()</code> calls being made to setup
the process's memory mappings. Each call to <code>mmap()</code> ends up with the same
address each time, right? Let's re-enable ASLR on your operating system:</p>
<pre><code class="language-bash">echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
</code></pre>
<p>Now, run <code>strace</code> on <code>/bin/ls</code> a couple times. You should see that the
results of the <code>mmap()</code> calls are no longer the same each time <code>/bin/ls</code> is
invoked. The memory map of our <code>/bin/ls</code> process is being randomized each time
we execute it.</p>
<h2 id="breaking-aslr"><a class="header" href="#breaking-aslr">Breaking ASLR</a></h2>
<h3 id="is-it-possible-to-brute-force"><a class="header" href="#is-it-possible-to-brute-force">Is it possible to brute force?</a></h3>
<p>Well, it depends. In
<a href="https://web.stanford.edu/%7Eblp/papers/asrandom.pdf">this paper</a> researchers
demonstrated that, with enough tries on the <em>same</em> memory mapping, attackers
could brute force the <code>delta_mmap</code> value described in <a href="exploit-mitigations/aslr.html#references">[4]</a>.
Symbols in <code>libc</code> have static offsets, we can find these by using <code>objdump</code>. If
we know the usual base address of <code>libc</code> within process memory, we can compute
the address of our target symbol and then account for the entropy introduced by
ASLR. A condition that enabled the researchers to continuously brute force a
target to determine its <code>delta_mmap</code> value is that the parent process executed
<code>fork()</code> each time a connection was made. When a process <code>fork()</code>s, the child
process's memory mapping will be identical to the parent's. The researchers
could crash the child process as many times as necessary to discover the
<code>delta_mmap</code> value. Once they discovered the <code>delta_mmap</code> value, the
researchers computed the base address of <code>libc</code> within the target's memory, 
allowing them to compute the location of any symbol in the target's <code>libc</code> to
build the final payload.</p>
<h3 id="other-methods"><a class="header" href="#other-methods">Other methods?</a></h3>
<p>Another interesting thing to think about is the amount of entropy introduced by
a system's implementation of ASLR. If the number of bits randomized within the
virtual address space of a process is small enough, even if the process doesn't 
<code>fork()</code> like in the example above and the mapping is different on each
invocation, we could still feasibly brute force the location of <code>libc</code> symbols
in memory with enough guesses.</p>
<p>A common method of beating ASLR is through utilizing some sort of sensitive
information leak, like a format string vulnerability. <a href="exploit-mitigations/aslr.html#references">[6]</a> If an
attacker can leak information from the process to discover the location of a
<code>libc</code> symbol in the process's memory, the attacker can calculate the base
of <code>libc</code> within the process's memory, beating ASLR. <a href="exploit-mitigations/aslr.html#references">[7]</a></p>
<h2 id="references-27"><a class="header" href="#references-27">References</a></h2>
<ol>
<li><a href="http://phrack.org/issues/49/14.html">http://phrack.org/issues/49/14.html</a></li>
<li><a href="https://seclists.org/bugtraq/1997/Aug/63">https://seclists.org/bugtraq/1997/Aug/63</a></li>
<li><a href="https://pax.grsecurity.net/">https://pax.grsecurity.net/</a></li>
<li><a href="https://pax.grsecurity.net/docs/aslr.txt">https://pax.grsecurity.net/docs/aslr.txt</a></li>
<li><a href="https://web.stanford.edu/%7Eblp/papers/asrandom.pdf">https://web.stanford.edu/~blp/papers/asrandom.pdf</a></li>
<li><a href="https://cs155.stanford.edu/papers/formatstring-1.2.pdf">https://cs155.stanford.edu/papers/formatstring-1.2.pdf</a></li>
<li><a href="http://phrack.org/issues/59/9.html#article">http://phrack.org/issues/59/9.html#article</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-execution-prevention-depnx"><a class="header" href="#data-execution-prevention-depnx">Data Execution Prevention (DEP)/NX</a></h1>
<p>In the <a href="exploit-mitigations/./aslr.html">previous section</a> we briefly discussed the article,
&quot;<em>Smashing the Stack for Fun and Profit</em>&quot;, where hacker, <strong>Aleph One</strong>,
described how to exploit stack buffer overflow vulnerabilities, executing
shellcode injected into a process's stack segment. The viability of the
techniques described in this article relied upon the fact that, at the time of
its writing, there was no delineation between code and data for the memory
segments of a process. <a href="exploit-mitigations/dep.html#references">[1]</a> After a significant proliferation of
computer worms <a href="exploit-mitigations/dep.html#references">[2]</a><a href="exploit-mitigations/dep.html#references">[3]</a> using these techniques
occurred, operating system designers and engineers began to implement the <code>W^X</code>
memory protection policy for process memory pages in an attempt to mitigate
exploitation.</p>
<h2 id="what-is-wx"><a class="header" href="#what-is-wx">What is W^X?</a></h2>
<p><code>W^X</code> (write xor execute) is the idea that memory should be writeable or
executable, but not both. Enforcement of this policy creates a delineation
between code and data within process memory, code being <code>r-x</code> and data being
<code>rw-</code>. Now when an attempt is made to execute machine code in a <code>rw-</code> segment,
an exception is raised. <a href="exploit-mitigations/dep.html#references">[4]</a></p>
<h2 id="what-is-nx"><a class="header" href="#what-is-nx">What is NX?</a></h2>
<p>The <code>NX</code> (No eXecute) bit is a hardware feature that, in conjuction with
operating system software, can be used to segregate memory pages into code
segments and data segments, enforcing the <code>W^X</code> memory protection policy.
<a href="exploit-mitigations/dep.html#references">[5]</a> While most modern processor architectures support the <code>NX</code>
bit, earlier implementations did not support this feature - kernel patches like
PaX <a href="exploit-mitigations/dep.html#references">[6]</a> and Exec Shield <a href="exploit-mitigations/dep.html#references">[7]</a> were designed to
emulate <code>NX</code> bit functionality.</p>
<h2 id="what-is-dep"><a class="header" href="#what-is-dep">What is DEP?</a></h2>
<p><code>DEP</code> (Data Exeuction Prevention) is Microsoft's implementation of the <code>NX</code>
functionality on Windows operating systems. <a href="exploit-mitigations/dep.html#references">[8]</a> Windows also
implements a software <code>DEP</code> feature that avoids the use of the <code>NX</code> bit called
SafeSEH (Safe  Structured Exception Handling). <a href="exploit-mitigations/dep.html#references">[9]</a> If a process
raises an exception, SafeSEH enforces an integrity check of the stored
exception handler, checking the exception handler against the one that was
originally present when the application was compiled. This prevents an attacker
from modifying the exception handler and intentionally raising an exeception to
hijack control of the process.</p>
<h2 id="breaking-wx"><a class="header" href="#breaking-wx">Breaking W^X</a></h2>
<p>As mentioned in the <a href="exploit-mitigations/./aslr.html">previous section</a>, <strong>Solar Designer</strong> published
the article, &quot;<em>Getting around the non-executable stack, (and fix)</em>&quot;, detailing
how to conduct a <code>ret2libc</code> attack. The attack involves conducting a stack
buffer overflow to hijack the control flow of the process, however, instead of
jumping into the stack to execute shellcode, the attacker returns into <code>libc</code>'s
<code>system()</code> symbol. This method defeats the <code>W^X</code> memory protection policy
because control flow is redirected to a segment of memory that is <code>r-x</code>. An
exception will not be rasied when the instructions of <code>libc</code>'s <code>system()</code>
are executed. <a href="exploit-mitigations/dep.html#references">[10]</a></p>
<p><a href="exploit-mitigations/../return-oriented-programming/aslr-nx.html">Return oriented programming</a> takes
this a step further. Utilizing the stack pointer as an artificial program
counter, an attacker places words on the stack that point to valid instruction
sequences within process memory (<code>ROP</code> gadgets). <code>ROP</code> gadgets reside within a
section of memory that is labeled as code (<code>r-x</code>) - usually in <code>libc</code>. A
sufficient number of <code>ROP</code> gadgets provides Turing complete functionality for an
attacker, allowing them to compute anything necessary to exploit a vulnerable
application.</p>
<p>Another surface presenting a method to bypass <code>W^X</code> is Just-In-Time (JIT)
compilation. JIT compilation involves compiling code at runtime before
executing it, usually supported by applications like browsers in order to
implement things like JavaScript engines. Sometimes, the memory pages created
by browsers to store and execute JIT compiled code don't enforce the <code>W^X</code>
memory protection policy. This has been used by attackers to execute a
technique known as JIT spraying. JIT spraying involves the injection of
malicious code into <code>rwx</code> pages of an application that supports JIT
compilation. With a viable method to hijack the control flow of the
application and a sensitive information leak, the attacker returns into the
sprayed memory page to gain arbitrary code execution. <a href="exploit-mitigations/dep.html#references">[11]</a></p>
<h2 id="references-28"><a class="header" href="#references-28">References</a></h2>
<ol>
<li><a href="http://phrack.org/issues/49/14.html">http://phrack.org/issues/49/14.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Sasser_(computer_worm)">https://en.wikipedia.org/wiki/Sasser_(computer_worm)</a></li>
<li><a href="https://en.wikipedia.org/wiki/Blaster_(computer_worm)">https://en.wikipedia.org/wiki/Blaster_(computer_worm)</a></li>
<li><a href="https://en.wikipedia.org/wiki/W%5EX">https://en.wikipedia.org/wiki/W%5EX</a></li>
<li><a href="https://en.wikipedia.org/wiki/NX_bit">https://en.wikipedia.org/wiki/NX_bit</a></li>
<li><a href="https://pax.grsecurity.net/docs/segmexec.txt">https://pax.grsecurity.net/docs/segmexec.txt</a></li>
<li><a href="https://lwn.net/Articles/31032/">https://lwn.net/Articles/31032/</a></li>
<li><a href="https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention">https://docs.microsoft.com/en-us/windows/win32/memory/data-execution-prevention</a></li>
<li><a href="https://docs.microsoft.com/en-us/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=vs-2019">https://docs.microsoft.com/en-us/cpp/build/reference/safeseh-image-has-safe-exception-handlers?view=vs-2019</a></li>
<li><a href="https://seclists.org/bugtraq/1997/Aug/63">https://seclists.org/bugtraq/1997/Aug/63</a></li>
<li><a href="http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Slides-v2.pdf">http://www.semantiscope.com/research/BHDC2010/BHDC-2010-Slides-v2.pdf</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="position-independent-executables-pies"><a class="header" href="#position-independent-executables-pies">Position Independent Executables (PIEs)</a></h1>
<p>Position independent code (PIC) is a term used to describe machine code that
executes properly regardless of its absolute address when loaded into memory.
Historically, code was position-dependent and the base address of the code
needed to be loaded into the same location in memory in order to execute
correctly. This is due to absolute addressing - some instructions were
referencing absolute locations in memory for load and store instructions, etc.
If position-dependent code were to be loaded into some different base address
than what's expected by the programmer, the program would not execute correctly
because instructions using absolute addressing would not be accessing
appropriate values.</p>
<p>In contrast, position independent code uses relative addressing - references to
locations in memory utilize some offset and the operands of instructions using
relative addressing are calculated at runtime. The <code>x86</code> and <code>x86-64</code>
architectures tackle the issue of resolving absolute addresses at runtime using
two different methods:</p>
<ul>
<li><code>x86</code> uses a fake function call in order to obtain a return address from the
stack. This function usually looks like this in a debugger:
<code>__x86.get_pc_thunk.bx</code></li>
</ul>
<p>The position of the code is loaded into the <code>ebx</code> register and instructions
using relative addressing utilize this value in order to acquire the absolute
address of their operand in memory. <a href="exploit-mitigations/position-independent-executables.html#references">[1]</a></p>
<ul>
<li>Instructions in <code>x86-64</code> are able to acquire the absolute address of their
operands by using the value of the <code>RIP</code> register with some offset. This is
definitely more efficient than a fake function call.</li>
</ul>
<h2 id="why-do-we-need-position-independent-code"><a class="header" href="#why-do-we-need-position-independent-code">Why do we need position independent code?</a></h2>
<p>Position independent code enables our use of shared libraries. Shared library
code can be loaded into any location within process memory and, because it's
position independent, it will execute correctly. This also allows a process
to load multiple shared libraries into memory without having to worry about
address space collisions. <a href="exploit-mitigations/position-independent-executables.html#references">[2]</a> p. 1-3</p>
<h2 id="how-are-symbols-resolved-for-a-shared-library"><a class="header" href="#how-are-symbols-resolved-for-a-shared-library">How are symbols resolved for a shared library?</a></h2>
<p>A shared library's exported symbols will be in different locations each time it
is loaded into process memory. Fortunately for us, we have the Global Offset
Table (GOT) mechanism to help us resolve the absolute address of the symbols at
runtime. <a href="exploit-mitigations/position-independent-executables.html#references">[3]</a> When an object file is loaded into process memory,
the dynamic linker processes the relocation entries of the file, determines the
associated symbol values for the relocation entries, and then calculates the
absolute addresses of the symbols. The dynamic linker then sets the GOT entries
to the correct values for the symbols.</p>
<p>When an executable file makes a function call to a function exported by a
shared library, the procedure linkage table will handle the function call and
the dynamic linker will resolve the absolute address of the requested function.
The dynamic linker then stores the absolute address of the function call in the
executable's GOT, and execution is redirected using the absolute address that
was resolved and stored in the executable's GOT. <a href="exploit-mitigations/position-independent-executables.html#references">[4]</a></p>
<h3 id="exposition-on-the-procedure-linkage-table-plt"><a class="header" href="#exposition-on-the-procedure-linkage-table-plt">Exposition on the Procedure Linkage Table (PLT)</a></h3>
<p>While the Global Offset Table handles position-independent address calculations
to absolute locations, the PLT handles position-independent function calls to
absolute locations. The linker is unable to resolve execution transfers
(function calls) of position-independent code from one executable to another,
or to a shared object, so it leverages this responsibility onto the program
using the program's PLT.</p>
<p>The structure of the PLT is as follows:</p>
<ul>
<li>The special first entry of the PLT - contains code to call the dynamic linker
for symbol resolution, providing the linker with the offset into the symbol
table and the address of a structure that identifies the location of the
caller.</li>
<li>The succeeding structures in the PLT are used to handle function calls into
shared objects.
<ul>
<li>The first address in each structure contains a <code>JUMP</code> instruction into the
GOT entry for the symbol.</li>
<li>If the absolute address of the symbol is not resolved in the GOT, program
execution returns back to this second entry in the <code>symbol@PLT</code> structure. This
entry then <code>PUSH</code>es the ID of the symbol to be resolved to the stack. IDs for
each symbol can be found in the <code>_DYNAMIC</code> section of the program.</li>
<li>This entry <code>JUMP</code>s into the first, special entry of the PLT - the call to
the dynamic linker. The dynamic linker will use the ID previously <code>PUSH</code>ed to
the stack and attempt to resolve the desired symbol in the shared object. If
the dynamic linker is able to resolve the absolute address of the symbol in
the shared object, it stores the address in the GOT and then transfers
execution to the function in the shared object. All future references to this
<code>symbol@PLT</code> will immediately <code>JUMP</code> to the resolved address in the GOT.</li>
</ul>
</li>
</ul>
<p>The steps described above only occur if the program is leveraging &quot;lazy linking&quot;,
or <strong>Partial RELRO</strong>. When <strong>Full RELRO</strong> is enabled, all external symbols in the
<code>_DYNAMIC</code> section are resolved to their absolute addresses in each shared object
and marked <code>r-x</code> by the loader prior to program execution. <a href="exploit-mitigations/position-independent-executables.html#references">[4]</a></p>
<h2 id="so-then-whats-a-position-independent-executable"><a class="header" href="#so-then-whats-a-position-independent-executable">So then, what's a position independent executable?</a></h2>
<p>Position independent executables (PIEs) are executable files made entirely from
position independent code. How this affects security and performance will be
covered in the next section.</p>
<h2 id="references-29"><a class="header" href="#references-29">References</a></h2>
<ol>
<li><a href="https://stackoverflow.com/questions/6679846/what-is-i686-get-pc-thunk-bx-why-do-we-need-this-call">https://stackoverflow.com/questions/6679846/what-is-i686-get-pc-thunk-bx-why-do-we-need-this-call</a></li>
<li><a href="ftp://bitsavers.informatik.uni-stuttgart.de/pdf/intel/iRMX/iRMX_86_Rev_6_Mar_1984/146196_Burst/iRMX_86_Application_Loader_Reference_Manual.pdf">ftp://bitsavers.informatik.uni-stuttgart.de/pdf/intel/iRMX/iRMX_86_Rev_6_Mar_1984/146196_Burst/iRMX_86_Application_Loader_Reference_Manual.pdf</a></li>
<li><a href="https://wiki.gentoo.org/wiki/Hardened/Position_Independent_Code_internals">https://wiki.gentoo.org/wiki/Hardened/Position_Independent_Code_internals</a></li>
<li><a href="https://refspecs.linuxfoundation.org/ELF/zSeries/lzsabi0_zSeries/x2251.html">https://refspecs.linuxfoundation.org/ELF/zSeries/lzsabi0_zSeries/x2251.html</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exploiting-pies"><a class="header" href="#exploiting-pies">Exploiting PIEs</a></h1>
<p>In previous sections we discussed how ASLR affects exploitation and what
requirements must be met by an attacker in order to break the randomization of
a target's addresses in memory. The requirements and methods in order to
effectively exploit PIEs are quite similar.</p>
<h2 id="whats-available-to-an-attacker-when-the-target-is-not-a-pie"><a class="header" href="#whats-available-to-an-attacker-when-the-target-is-not-a-pie">What's available to an attacker when the target is not a PIE?</a></h2>
<p>When an executable file is not position independent, the sections can all be
statically-addressed. A non-PIE ELF binary will be loaded into the same base
address in virtual memory each time it is executed. This behavior can be seen
with any non-PIE binary by using the <code>size</code> command:</p>
<pre><code class="language-bash">size --format=sysv &lt;non-PIE binary&gt;
</code></pre>
<p>This command will display the sections of the non-PIE binary and the starting
address for each section. Each section will have a static address.
<a href="exploit-mitigations/exploiting-pies.html#references">[1]</a></p>
<p>Why is this significant for an attacker? The attacker will always know where
important resources are in the executable file, these resources can include:</p>
<ul>
<li>The <code>.got</code> and <code>.got.plt</code> sections - useful for gaining control of the
program counter if a write primitive is available.</li>
<li>The <code>.data</code> and <code>.bss</code> sections - useful for reading and writing data / 
conducting stack pivots, etc.</li>
</ul>
<p>With knowledge of these static addresses, an attacker can use the non-PIE
behavior of the ELF binary to construct ROP chains using the code available -
everything is statically-addressed so the gadgets will always be in the same
location. Contrast this with how attackers must utilize sensitive information
leaks in order to overcome ASLR to determine the locations of their ROP gadgets
within shared objects such as <code>glibc</code>.</p>
<h2 id="so-do-pies-break-rop"><a class="header" href="#so-do-pies-break-rop">So do PIEs break ROP?</a></h2>
<p>Again, the methods to overcome PIEs and ASLR are similar. When a binary ELF is
position independent, all of the sections will be dynamically-addressed. The
sections of the ELF will start with some offset - this can be seen by using
the same <code>size</code> command specified above on a PIE ELF binary. <a href="exploit-mitigations/exploiting-pies.html#references">[1]</a></p>
<p>A PIE ELF binary will be loaded into a different base address in virtual memory
each time it is executed. This behavior increases the difficulty for an
attacker to utilize the resources identified earlier, and it also removes the
attacker's ability to use statically-addressed ROP gadgets.</p>
<p>Similiar to how an attacker must overcome ASLR in order to generate a ROP
chain, a sensitive information leak must be conducted in order to determine the
base address of the ELF in virtual memory. This can be done by leaking a return
address from the stack, a pointer to some location in <code>.data</code>, and so on.</p>
<h2 id="are-there-primitives-other-than-an-information-leak-that-can-be-used-to-defeat-pie-how-might-the-related-vulnerabilities-manifest-themselves"><a class="header" href="#are-there-primitives-other-than-an-information-leak-that-can-be-used-to-defeat-pie-how-might-the-related-vulnerabilities-manifest-themselves">Are there primitives other than an information leak that can be used to defeat PIE? How might the related vulnerabilities manifest themselves?</a></h2>
<p>Yes, the previous discussion on how to defeat PIE was mostly concerned with how
an attacker could generate a ROP chain, but there are other solutions that
aren't stack based.</p>
<p>Some conditions could exist in which the attacker could use a heap based
vulnerability to gain code execution, these include:</p>
<ul>
<li>A write-what-where condition <a href="exploit-mitigations/exploiting-pies.html#references">[2]</a></li>
<li>Use after free <a href="exploit-mitigations/exploiting-pies.html#references">[3]</a></li>
<li>Double free <a href="exploit-mitigations/exploiting-pies.html#references">[4]</a></li>
</ul>
<p>A good example of gaining code execution without needing an information leak
to determine the base address of the binary is 0CTF's BabyHeap2017 challenge.
<a href="exploit-mitigations/exploiting-pies.html#references">[5]</a> For this challenge, the attacker conducts a fastbin attack
to leak a <code>libc</code> address - in this case an address from the <code>main_arena</code>
structure in <code>libc</code>. After using this <code>libc</code> information leak to defeat ASLR,
the attacker uses the same fastbin attack to conduct a write to <code>libc</code>'s
<code>__malloc_hook</code> function pointer, overwriting it with a <code>one_gadget</code>. The next
time <code>malloc</code> is called by the program, the attacker gains code execution.</p>
<p>Another example provided by reference <a href="exploit-mitigations/exploiting-pies.html#references">[3]</a> discusses how a
Use After Free vulnerability could be used to overwrite function pointers that
may be scattered in the heap. An attacker could overwrite the function pointer
with an address to shellcode, achieving arbitrary code execution.</p>
<h2 id="references-30"><a class="header" href="#references-30">References</a></h2>
<ol>
<li><a href="https://access.redhat.com/blogs/766093/posts/1975793">https://access.redhat.com/blogs/766093/posts/1975793</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/123.html">https://cwe.mitre.org/data/definitions/123.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/416.html">https://cwe.mitre.org/data/definitions/416.html</a></li>
<li><a href="https://cwe.mitre.org/data/definitions/415.html">https://cwe.mitre.org/data/definitions/415.html</a></li>
<li><a href="https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html">https://uaf.io/exploitation/2017/03/19/0ctf-Quals-2017-BabyHeap2017.html</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack-canaries"><a class="header" href="#stack-canaries">Stack canaries</a></h1>
<p><strong>Stack canaries</strong> or <strong>stack cookies</strong> are values that are placed onto the
stack to monitor and protect sensitive information, such as the frame pointer
or a function's return address, from buffer overflows or stack smashing. Stack
canaries are usually placed between buffers and control data on the stack. The
terminology for stack canaries is derived from the historic practice of using
canaries in coal mines. Canaries would be affected by toxic gases much earlier
than the miners, providing a biological warning system.</p>
<h2 id="stack-canary-implementations"><a class="header" href="#stack-canary-implementations">Stack canary implementations</a></h2>
<p>Multiple stack canary implementations exist, starting from their inception in
the early 2000's. Stack canaries were created because buffer overflow exploits
were very popular at the time. They are one of the many different protection
mechanisms that were created in an attempt to thrwart the exploitation of this
vulnerability class. I'm only going to cover the most prominent examples.</p>
<h3 id="stackguard"><a class="header" href="#stackguard">StackGuard</a></h3>
<p>StackGuard was a modification for GCC, adding new code to function prologues
and epilogues. StackGuard pushes a <strong>terminator canary</strong> onto the stack and
checks the value of the terminator canary before conducting the final <code>ret</code> of
the function.</p>
<p>A <strong>terminator canary</strong> is a canary that contains characters usually used to
terminate strings or input from functions like <code>gets()</code>, these characters
being: <code>0x000aff0d</code>. The thought process behind StackGuard and terminator
canaries is that the attacker will be unable to overwrite the return address
on the stack to gain control of the <code>EIP</code>/<code>RIP</code> if their payload must include
these bad characters - the input to overwrite the return address will be
terminated too early.</p>
<p>If the attacker somehow manages to mangle StackGuard's terminator canary, the
canary check will fail at the function epilogue and the program will jump to
<code>__canary_death_handler</code>, exiting execution. <a href="exploit-mitigations/stack-canaries.html#references">[1]</a></p>
<h3 id="bypassing-stackguard"><a class="header" href="#bypassing-stackguard">Bypassing StackGuard</a></h3>
<p>Referencing <a href="http://phrack.org/issues/56/5.html">this</a> Phrack article,
StackGuard may protect the return address of the function on the stack, however
, it neglects to protect the local variables from overwriting each other.
In the example, two <code>strcpy()</code> operations are conducted with one use of
<code>strcpy()</code> being vulnerable to an out-of-bounds write. Using this out-of-bounds
write, the attacker implements an arbitrary write primitive to overwrite the
return pointer. This probably wouldn't work with ASLR enabled, so a secondary
option would probably include overwriting some function pointer in the
<code>.plt.got</code> section to gain code execution - this is only useful if the binary
executable is not a PIE.</p>
<p>Another issue with StackGuard is that it does not protect the frame pointer on
the stack, allowing an attacker the ability to conduct a stack pivot.
<a href="exploit-mitigations/stack-canaries.html#references">[1]</a></p>
<h3 id="stack-smashing-protector"><a class="header" href="#stack-smashing-protector">Stack Smashing Protector</a></h3>
<p>Stack Smashing Protector (SSP) is a GCC compiler feature that detects stack
buffer overflows and aborts if the secret value (canary) on the stack is
changed. The stack canary used by SSP is randomly generated using
<code>/dev/urandom</code>, and the canary is a different value each time the program is
invoked.</p>
<p>The SSP is pretty easy to notice when disassembling a program. At the beginning
of each function prologue, the stack canary is acquired from thread local
storage and pushed onto the stack after the frame pointer. At the end of the
function epilogue, prior to calling <code>leave</code> or <code>ret</code>, the value of the canary
is fetched from the stack and compared against the value saved in thread local
storage with an <code>XOR</code> operation. If the outcome of this <code>XOR</code> operation is not
<code>0</code>, we have failed the canary check and the <code>__stack_chk_fail</code> function is
called, exiting program execution. <a href="exploit-mitigations/stack-canaries.html#references">[3]</a></p>
<h3 id="bypassing-ssp"><a class="header" href="#bypassing-ssp">Bypassing SSP</a></h3>
<p>There are multiple methods to bypass SSP, but some conditions must exist. Some
crowd favorites are:</p>
<ul>
<li>Using a format string vulnerability to conduct a sensitive information leak
in order to leak the value of the canary. <a href="exploit-mitigations/stack-canaries.html#references">[5]</a></li>
<li>Using an arbitrary write primitive to overwrite the value of
<code>__stack_chk_fail</code> in the global offset table and then intentionally failing
the canary check in order to gain code execution. <a href="exploit-mitigations/stack-canaries.html#references">[6]</a></li>
<li>If a server process uses <code>fork()</code> to handle multiple connections, attackers
can brute force the value of the canary because the value of the canary will
not change for child processes. <a href="exploit-mitigations/stack-canaries.html#references">[4]</a></li>
</ul>
<h2 id="references-31"><a class="header" href="#references-31">References</a></h2>
<ol>
<li><a href="https://www.coresecurity.com/sites/default/files/private-files/publications/2016/05/StackguardPaper.pdf">https://www.coresecurity.com/sites/default/files/private-files/publications/2016/05/StackguardPaper.pdf</a></li>
<li><a href="http://phrack.org/issues/56/5.html">http://phrack.org/issues/56/5.html</a></li>
<li><a href="https://wiki.osdev.org/Stack_Smashing_Protector">https://wiki.osdev.org/Stack_Smashing_Protector</a></li>
<li><a href="https://ctf101.org/binary-exploitation/stack-canaries/">https://ctf101.org/binary-exploitation/stack-canaries/</a></li>
<li><a href="https://spotless.tech/angstrom-ctf-2020-Canary.html">https://spotless.tech/angstrom-ctf-2020-Canary.html</a></li>
<li><a href="https://dunsp4rce.github.io/redpwn-2020/pwn/2020/06/26/dead-canary.html">https://dunsp4rce.github.io/redpwn-2020/pwn/2020/06/26/dead-canary.html</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safe-list-unlinking"><a class="header" href="#safe-list-unlinking">Safe list unlinking</a></h1>
<h2 id="history"><a class="header" href="#history">History</a></h2>
<p>Before we talk about safe list unlinking, let's discuss <strong>unsafe</strong> list
unlinking.</p>
<p>In 2001, Michel &quot;MaXX&quot; Kaempf wrote the Phrack Article &quot;<em>Vudo malloc tricks</em>&quot;
<a href="exploit-mitigations/safe-list-unlinking.html#references">[1]</a>. In this article, he describes multiple different techniques
for corruption and exploitation of the heap. For this discussion, we're
interested in topic <strong>3.6.1 - The unlink() technique</strong>.</p>
<p>Gaining arbitrary code execution using <strong>the unlink() technique</strong> was first
introduced by &quot;Solar Designer&quot;. The technique tricks <code>dlmalloc</code> into processing
carefully crafted forward, <code>fd</code>, and backward, <code>bk</code>, pointers of a chunk being
<code>unlink()</code>ed from a doubly linked list. Abusing the <code>unlink()</code> macro in this
manner provides an attacker the ability to conduct an arbitrary write to any
location in memory which can lead to arbitrary code execution. The <code>unlink()</code>
macro is as follows:</p>
<pre><code class="language-c">#define unlink( P, BK, FD ) {   \
    BK = P-&gt;bk;                 \
    FD = P-&gt;fd;                 \
    FD-&gt;bk = BK;                \
    BK-&gt;fd = FD;                \
}
</code></pre>
<p>The proof of concept provided in this article leverages a heap buffer overflow
to overwrite the chunk metadata of a succeeding chunk, clearing the
<code>PREV_INUSE</code> bit and tricking <code>malloc</code> into thinking that the overflown chunk
is currently free. When the corrupted chunk is <code>free()</code>d, <code>malloc</code>
consolidates the two chunks, executing the <code>unlink()</code> macro on the overflown
chunk - triggering a reflective write. Because the attacker controls the user
data of the overflown chunk, the attacker can craft the <code>fd</code> and <code>bk</code> pointers.
In this example, the <code>fd</code> pointer is the address of an imaginary chunk that
overlaps with the <code>__free_hook</code>, and the <code>bk</code> pointer is the address of an
imaginary chunk that overlaps the shellcode.</p>
<p>At the time this article was written, W^X mitigations for memory segments were
uncommon. The proof of concept stores <code>sys_execve(&quot;/bin/sh&quot;, NULL, NULL)</code>
shellcode on the heap, uses the arbitrary write to write the heap address of
the shellcode to the <code>__free_hook</code>, and then executes <code>free()</code> to gain code
execution. The shellcode accounts for the reflective write conducted by
<code>unlink()</code> at the <code>fd</code> of the imaginary chunk that overlaps the shellcode. The
shellcode executes a <code>jmp</code> to avoid executing the invalid instructions
represented by the <code>fd</code> pointer.</p>
<h2 id="safe-unlinking"><a class="header" href="#safe-unlinking">Safe unlinking</a></h2>
<p><strong>The unlink() technique</strong> was used to exploit a number of vulnerable
applications and, surprisingly, it took a while before a fix was implemented
for <code>glibc</code>. It wasn't until <code>glibc 2.3.4</code>, released in 2004, that checks were
implemented for the <code>fd</code> and <code>bk</code> pointers of chunks being operated upon by
<code>unlink()</code>. The updated <code>unlink()</code> macro can be found below <a href="exploit-mitigations/safe-list-unlinking.html#references">[2]</a>:</p>
<pre><code class="language-c">#define unlink( P, BK, FD ) {                                               \
    BK = P-&gt;bk;                                                             \
    FD = P-&gt;fd;                                                             \
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                   \
        malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P);  \
    else {                                                                  \
        FD-&gt;bk = BK;                                                        \
        BK-&gt;fd = FD;                                                        \
    }                                                                       \
}
</code></pre>
<p>In the updated <code>unlink()</code> macro, a check is now conducted to ensure that the
<code>bk</code> of the <code>fd</code> chunk pointed to by the chunk being inspected, <code>P</code>, is <code>P</code>. A
check is also conducted to ensure that the <code>fd</code> of the <code>bk</code> chunk pointed to by
the chunk being inspected, <code>P</code>, is <code>P</code>. This prevents an attacker from setting
the <code>fd</code> and <code>bk</code> of <code>P</code> to arbitrary locations in memory, thwarting the
previous technique's method of using imaginary chunks for arbitary writes. If
the program fails this check, the process raises the <code>SIGABRT</code> signal and
terminates execution.</p>
<p>This mitigation has been proven to still be exploitable, it just requires
specific circumstances to be feasible. A good example of a situation in which
an attacker could still exploit this technique is if a pointer to the overflown
chunk is present in some location in memory that the attacker can control, such
as <code>.data</code> or <code>.bss</code>. The attacker can then craft the <code>fd</code> and <code>bk</code> pointers
of the overflown chunk to point to imaginary chunks that overlap the portion
of <code>.data</code> containing the heap pointer of the overflown chunk. This technique
spoofs valid <code>fd</code> and <code>bk</code> chunks that will pass the updated <code>unlink()</code>
check. If the program uses this location in <code>.data</code> to track heap chunk
addresses for management and editing of data, the attacker can abuse this
technique to corrupt pointers in <code>.data</code>, eventually creating an arbitrary
write primitive.</p>
<h2 id="later-mitigations"><a class="header" href="#later-mitigations">Later mitigations</a></h2>
<p>As more techniques for exploiting <code>unlink()</code> were discovered, more patches were
released for <code>glibc</code> to mitigate exploitation of this mechanism. A good example
is the below code that was implemented for the <code>unlink_chunk()</code> function in
<code>malloc</code>. This code checks that the next chunk's <code>prev_size</code> field matches the
current chunk's <code>size</code> field:</p>
<pre><code class="language-c">static void
unlink_chunk (mstate av, mchunkptr p)
{
  if (chunksize (p) != prev_size (next_chunk (p)))
    malloc_printerr (&quot;corrupted size vs. prev_size&quot;);

&lt;...snip...&gt;
</code></pre>
<p>Patches continue to be released that work to harden <code>glibc</code>'s implementation of
<code>malloc</code>, the most recent patch being in 2019.</p>
<h2 id="references-32"><a class="header" href="#references-32">References</a></h2>
<ol>
<li><a href="http://phrack.org/issues/57/8.html">http://phrack.org/issues/57/8.html</a></li>
<li><a href="http://phrack.org/issues/66/10.html">http://phrack.org/issues/66/10.html</a></li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:9000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
